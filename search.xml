<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[解决笔记本上安装Linux的显卡、音频问题]]></title>
      <url>%2F2018%2F03%2F02%2Fmsi-ubuntu-setup%2F</url>
      <content type="text"><![CDATA[有显卡弄机器学习、打游戏都方便些，因此新入了有台gtx 1060的微星笔记本。 显卡驱动对于我来说，ubuntu 比 windows 要方便些，但没想到安装后，系统无法进入，应该是显卡驱动的问题。查了之后如下方式解决： 进入 grub 后， 按e进入启动项编辑。 在 splash 后添加 nomodset 参数，使得ubuntu 使用最低分辨率进入系统。 然后在ubuntu自己的附加驱动设置中安装英伟达驱动。 关机破音解决方式： 在/etc/modprobe.d/创建一个 modprobe.conf，在该文件内写入: options snd-hda-intel model=,generic 通过alsamixer 配置音频参数 sudo alsamixer选择sound card（HDA INTEL PCH）设置auto mute 为 disabled另外调整其余出现红色的参数 其他 主题： FlatabulousAdapta 图标主题 La Capitaineultra-flat 鼠标 capitaine]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DL1 Introduction]]></title>
      <url>%2F2017%2F11%2F28%2Fdeeplearning%2FDL1%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[interview-tencent-2]]></title>
      <url>%2F2017%2F11%2F28%2Finterview%2Finterview-tencent-2%2F</url>
      <content type="text"><![CDATA[研三校招，内推时候面的一、二面，校招时候总监面。一、二面都过了，跪在总监了。哈。 腾讯面试 linux内存调度机制？虚拟地址，段页表 查看tcp连接命令？ netstat -apn 查看内存使用率及内存泄露？ top、jstat、jinfo、jps、jconsole jvm内存管理机制？分代、可达性分析 服务端大量tcp链接进入time_wait 状态，为什么，客户端相应状态是什么？ 服务端关闭tcp链接，客户端是closed mysql 索引类型？ 单列索引、组合索引 组合索引注意什么？ 列组合需要唯一。。。 两台服务器部署app，使用hibernate做orm hibernate的缓存？ 两级缓存 如何确保缓存一致？ 没答出来。 分布式协议？ paxos、gossip 算法题 走n级楼梯，一次只能走1步或2步。问有几种走法？递归就行]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HanoiTower]]></title>
      <url>%2F2017%2F08%2F29%2Falgorithm%2FHanoiTower%2F</url>
      <content type="text"><![CDATA[问题经典的算法问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？ 如果强暴的尝试每一种移动圆盘的可能，那需要的操作步骤可能是难以想象的，特别是当圆盘越来越多之后。 分解经过思考，可以发现，要将n个圆盘从 a 移动到 c。可以先将最后一个圆盘之上的 n-1 个圆盘都移动到 b 上，把最后一个圆盘移动从 a 移动到 c 上。此时问题就转化为将剩下的n-1个圆盘从 b 移动到 c上。 重复递推此过程，当递推剩下一个盘子的时候，便可将盘子移动到目标柱上！ 给出python代码： 1234567891011# 输出： [盘子序号] [当前所处柱] --&gt; [移往的柱] def solve(n , a, b, c): if len(n) == 1: print(n, a, '--&gt;', c) else: solve(n[:-1], a, c,b) solve(n[-1:], a, b, c) solve(n[:-1], b, a, c)arr = list(range(3))slove(arr, 'a', 'b', 'c') 参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[美团提前批面试]]></title>
      <url>%2F2017%2F08%2F29%2Finterview%2Finterview-meituan-1%2F</url>
      <content type="text"><![CDATA[新岸同学帮忙内推的美团，🙏了。但是汉诺塔编程问跪了，非常基础的一道题，😓 三次握手、四次挥手502：网关错误 404 400 500 300 临界区：多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用，一次仅允许一个进程使用的资源称为临界资源。使用临界资源的代码段称为临界区 死锁，死锁条件 重载了 equals 方法， 为什么还要重载hashcode方法 CheckedError、 RuntimeError threadlocal. 作用，实现原理 ThreadPoolExecutor(参数) 哪几种. Spring AOP 原理：动态代理 Redis 存储数据类型，数据库事务隔离级别。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微品会提前批面试]]></title>
      <url>%2F2017%2F08%2F29%2Finterview%2Finterview-vip-1%2F</url>
      <content type="text"><![CDATA[非常差的面试体验。一面面试官放飞机？约的时间内居然没有面试电话，过几天又打过来了。。。 二面又推迟？？？然后说后面等hr， 一直没消息了。 真的服。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阿里巴巴内推面试]]></title>
      <url>%2F2017%2F08%2F29%2Finterview%2Finterview-ali-2%2F</url>
      <content type="text"><![CDATA[顺利拿到阿里offer，开心^_^。 想记记三面与hr面。 三面三面面试官让我深深感受到了实力的碾压，确实很佩服面试官技术的深度。从这次面试中我学到如何恰当的描述一个数据工程。 描述数据项目我认为从以下几个角度： 项目要解决什么问题。（项目的价值） 项目中有什么难点。 如何获取数据？（处理数据、洗数据方法等） 用什么方法提取数据中的价值。 效果如何？ （项目是否确实的解决了问题，效率如何？） svm 手推公式，记不住了。玻尔兹曼机，这个真不会，太久以前的技术了，有时间补补。 hr面无他，失败的聊天技巧。。。嘴笨。确实发现自己和女性聊天能把天聊死的技能点了。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hadoop]]></title>
      <url>%2F2017%2F08%2F05%2Fhadoop%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[阿里巴巴面试]]></title>
      <url>%2F2017%2F07%2F01%2Finterview%2Finterview-ali-1%2F</url>
      <content type="text"><![CDATA[找实习中，心好累，挺希望能去阿里的，结果最好还是拒了，今年可能真的水逆吧！可能第一面表现的不太好，写的map排序太差了，没做对。个人觉得二面，和hr面都面的挺好。希望秋招能又机会😄。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[南方基金面试]]></title>
      <url>%2F2017%2F06%2F20%2Finterview%2Finterview-southern-1%2F</url>
      <content type="text"><![CDATA[南方基金的面试流程颇为奇怪，不过据说基金类的面试都差不多。。。先是逐个自我介绍，然后介绍自己应聘的优点等，陆姐是给我印象最好的一个hr了。不得不说有为了高工资来南方的想法，然而实习工资并不高。也许对于其他行业来说算高了吧。呵，这里感觉技术实力确实不强，一切求稳，也有其道理。不过同事关系确实不错，享受这里的工作了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tensorflow - 2]]></title>
      <url>%2F2017%2F06%2F12%2Ftensorflow-2%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[微众银行面试]]></title>
      <url>%2F2017%2F06%2F10%2Finterview%2Finterview-webank-1%2F</url>
      <content type="text"><![CDATA[微众银行面试的时候，一面的时候吧，挺好的，面试官感觉到技术实力强，有抱负，有理想。二面的面试官看起来城府颇深，后来得知是大领导，不过颇为年轻了领导的话，可能和互联网有关吧，毕竟互联网比较年轻，嘻嘻。现在想起来，好后悔没去微众，微众给我的感觉还挺不错的，深圳这个城市渐渐喜欢上了，好想美女也挺多的！可惜我不认识😢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tensorflow - 1 简介、原理]]></title>
      <url>%2F2017%2F06%2F04%2Ftensorflow-1%2F</url>
      <content type="text"><![CDATA[只是关于TensorFlow，如果没有神经网络或机器学习相关知识的建议到此学习 简介TensorFlow 是Google的第二代分布式机器学习系统，于2015年11月开源，起源于 Google 内部的第一代分布式机器学习系统 DistBelief。前后端结构，后端使用c++开发而成，通过前端支持Python、C++、Java等开发语言，主要特性利用Gpu加速，以及分布式并行计算。 核心概念计算图TensorFlow 使用计算图「Computing Graph」，即用有向图「directed graph」表示计算流程，其中每一个运算操作「operation」 作为一个节点「node」 每个节点都是一个Operation。节点间的连线称为边，在计算中流动的数据称为张量「Tensor」， 这也就是「TensorFlow」名字的来源，Tensor 在 Operation之间传递。如下图（Constant操作产生常量Tensor）： 计算图「Graph」由 Tensor 和 Operation 组成。TensorFlow程序的构建分为构建阶段与执行阶段。即构建图、然后在Session中运行图 12345678# tf 含有一个默认的计算图，计算操作会添加到计算图中，通过如下调用获取默认的计算图tf.get_default_graph()# 通过 tf.Graph() 生成新的计算图,并定义图中计算,并可为每个图定义计算设备等。g1 = tf.Graph()with g1.as_default(): a = tf.Constant([1.0,2.0],name='a')with tf.Session(graph=g1) as sess: sess.run(tf.get_variable('a')) Session 可以通过上下文管理器的方式使用。避免了忘记close session 产生的泄漏问题。 123456789101112131415161718192021# 用法1sess = tf.Session()sess.run(...)sess.close()# 用法2 上下文管理器方式with tf.Session() as sess: ...sess = tf.Session()# 注册为默认会话with sess.as_default(): Tensor.eval() 或 Operation.run()# 交互式会话sess = tf.InterativeSession()Tensor.eval() 或 Operation.run()sess.close()# 通过ConfigProto配置sessionconfig = tf.ConfigProto(param1...)sess = tf.Session(config=config) 运算 Operation运算操作表示抽象计算（矩阵乘法、向量加法），运算通过其属性支持不同的tensor 类型，比如支持浮点数或整数。运算核是运算在某类硬件设备上的实现，tensorflow 通过「注册机制」添加新运算或运算核。 Collection 资源集合tf 通过 collection 管理不同类的资源，资源可以是张量、变量、或运行tensorflow 程序需要的队列资源。通过tf.add_to_collection() 将资源添加到集合中，tf自动管理的一些常用的集合： tf.GraphKeys.VARIABLES 所有变量 tf.GraphKeys.TRAINABLE_VARIABLES 可学习调整的变量 tf.GraphKeys.SUMMARIES 日志生成相关变量 tf.GraphKeys.QUEUE_RUNNERS 处理输入的QUEUE_RUNNERS tf.GraphKeys.MOVING_AVERAGE_VARIABLES 所有计算了滑动平均值的变量 会话 Sessiontensorflow 进行计算时必须要有一个session（通过session启动计算过程），session提供了计算图运行的环境，可以通过session的extend方法添加新的节点和边。seesion的run方法用以执行计算图。Variable 中的tensor会在计算执行后保留，而用户提供的tensor执行后并不会保存在内存中。 原理TensorFlow 使用的是master-worker的分布式设计，client 通过session连接master，master负责指导worker执行计算，每个worker可以与多个硬件设备相连接并负责管理硬件。TensorFlow有单机模式与分布式模式两种实现。如下图： 每个worker管理的设备的name表示为：”／job:xxx/任务号(单机模式没有)／device:硬件类别:硬件编号”，例子： 单机模式: /job:localhost/device:cpu:0 分布式模式: /job:worker/task:17/device:gpu:3 执行单机模式下，计算图按照依赖关系顺序执行，当节点的上游以来都被执行后，节点进入ready queue等待执行，同时下游节点依赖数也会减一。 分布式情况下两个问题： 节点在什么硬件设备上运行？ 通过估算节点计算时间分配到合适的设备上，同一设备上的相邻的节点会成为子图。 节点间通信？ 1.子图间边转化为设备上的发送节点、接收节点、以及发送节点到接收节点的边。如果设备上多个接收节点是同一个tensor，则这些接收节点合并为同一个接收节点。避免重复占用设备存储。 2.容错性：当数据发送失败、或worker心跳检测不到则计算图会被终止并重启，通过检查点（check point）保存和恢复可以避免重启后完全重来，保留模型参数。 3.variable node 连接Save node可以持久化存储，连接Restore node可以重启的时候恢复数据。 扩展功能 自动求导 正向执行后，反向回溯，涉及的问题有求导时以来之前的tensor，导致内存问题 单独执行子图 计算图控制流（Switch、Merge） 性能优化 异步 合并相同操作 降低重复计算 变换执行顺序 改善内存占用问题 并行计算模式 数据并行 模型并行 流水线并行 其他： 输入系统：1. feed node（通过client读取数据）、 2.input node 直接从文件系统读取数据 队列：tensorflow调度，比如预先读取下一个batch的数据 容器：管理长期变量 计算执行过程图： TensorFlow: A system for large-scale machine learning 后面会讲到正则化、滑动平均等问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习 模型评估与选择]]></title>
      <url>%2F2017%2F04%2F27%2FMachineLearning-2%2F</url>
      <content type="text"><![CDATA[经验误差 与 过拟合*(模型就是学习器) 错误率: 通常将分类错误的样本数占样本总数的比例称为“错误率”。即如果在m个样本中有a个样本分类错误，则错误率$E=\frac{a}{m}$, 相应的 $1-\frac{a}{m}$ 称为 “ 精度 ”。 误差： 把学习器在实际预测上输出与样本值的真是输出之间的差异称为“误差”，学习器在训练集上的“ 误差 ”称为“ 训练误差 ” 或 “ 经验误差 ”；在新样本上的误差称为 “ 泛化误差 ”。显然，我们希望得到“泛化误差”小的学习器。 过拟合(高方差): 当学习器将训练集样本学习得“太好”的时候，很可能将训练集中“自身特殊”的一些特点作为潜在样本具有的一般性质，这会导致“泛化性能”下降。这种现象称为“过拟合”。过拟合通常是因为学习能力过于强大而将不太一般的特性都学习了；过拟合解决比较麻烦，是机器学习的关键障碍。过拟合无法彻底避免，只能够缓解。因为机器学习的问题大都是“NP”难问题，而有效的学习算法必须在多项式时间内给出结果，若彻底避免过拟合，则通过经验误差最小化就能获得最优解，也就意味着产生了 “P=NP”，与现实矛盾。 欠拟合(高偏差): 与过拟合相对的就是“欠拟合”，欠拟合是指对于训练集上的一般性质尚未学习好。欠拟合是因为学习能力不足而造成的，欠拟合相对比较容易解决，比如决策数树中增加分支，神经网络中增加迭代次数。 模型选择在现实任务中，往往有多种学习算法可供选择，甚至对同个学习算法，使用不同的参数将产生多个模型。那么使用何种算法，使用何种参数？这就是机器学习中“模型选择” 的问题。理想的做法是对模型的“泛化误差”进行评估，选择泛化误差最小的模型。但在现实中无法直接获得“泛化误差”,在现实中如何进行模型的“评估” 与 “选择” ？ 评估方法通常可以通过实验测试来对学习器的泛化误差进行“评估”并进而做出“选择”。 测试集：需要一个样本集合来测试学习器对新样本的判别能力。以测试集上的 “测试误差” 作为 “泛化误差” 的近似。通常假设“测试样本” 也是从样本真是分布中独立同分布采样而得。唯一需要注意的是，测试集应该极尽可能的与训练集互斥。即测试样本不应该在训练样本中出现、未在训练中使用过（这其中的道理很好理解，比如考试遇见做过的题目很可能取得高分）。 当只有m个样本的数据集D，如何训练和测试呢？以下给出几种方法 留出法直接将数据集D 划分为两个互斥的集合S、T，其中一个集合S作为训练集，另一个集合T作为测试集，即 $ D = S \cup T, S \cap T= \emptyset $。 以二分类作为例子，假定D包含 1000 个样本，将其划分为S包含700个样本， T包含300个样本，用S进行训练后，如果模型在T上的有90个样本分类错误，那么其错误率就是$ \frac{90}{300} \times 100% = 30%$,相应的精度为 $1 - 30% = 70% $。 * 需要注意的是划分数据的过程中数据分布的一致性。避免在数据划分过程用引入额外的偏差而对最终结果产生影响，比如在分类中至少要保持相同的类别比例。从采样的角度看待数据集的划分过程，保留类别比例的采样方式通常称为“分层采样”。 单次使用留出法往往不够稳定可靠，因为划分方式的不同，比如排序后将正例按比例放入S、T中，会使得模型评估结果会有差别。因此一般采取若干次随机划分，重复进行试验后取平均值作为留出法的评估结果。 缺点: 由于我们想要评估由D训练得出的模型的性能，但留出法划分的训练集、测试集 会导致一个窘境！即如果训练集S包含大多数样本，则训练处的模型很可能接近于用D训练出的模型，但是由于T比较小，苹果结果可能不够稳定准确。 常见的做法是将大约$\frac{2}{3} $~ $\frac{4}{5}$ 的样本用于训练，剩余样本用于测试。 交叉验证法预先将数据集 D 划分为 k 个大小相似的互斥子集，即 $ D=D_1 \cup D_2 \cup … \cup D_k, D_i \cap D_j = \emptyset $。尽可能保证每个子集数据分布的一致性。每次用k-1个数据集作为训练集，余下的作为测试集；这样可以获得k组（训练集|测试集），从而可以进行k次训练和测试，最终返回k次测试结果的均值。我们显然可以发现，交叉验证法评估结果的稳定性和保真性很依赖k的取值，所以交叉验证法也称为“ k折交叉验证 ”。因为将数据集D划分为k个子集存在多种划分方式，为了减小因样本划分不同带来的差别，常随机使用不同的划分方式重复p次，最后评估p次k折交叉验证结果的均值，例如常见的“ 10次10折交叉验证”。 当数据集D有m个样本，当k=m时，则得到交叉验证法的特例：“ 留一法 ”，显然，留一法显然不受划分方式的影响。因为m个样本的集合划分为m个不相交的子集只有唯一的一种划分方式（每个子集包含一个样本）。 这就是的留一法的评估结果与期望使用D训练出的模型很相似，所以留一法往往被认为比较准确。但其存在的缺陷是：训练m个计算模型的开销可能是难以接受的，另外，留一法的评估结果也未必比其他评估方法准确（“没有免费的午餐”定理）。 自助法我们希望评估的是用D训练出的模型。可以发现，“ 留出法 ”与 “ 交叉验证法 ”中，由于保留一部分用于测试，因此实际评估使用的训练集比D小，必然会引入一些因训练规模不同而导致的“估计偏差”，“留一法”受样本规模影响较小，但是复杂度太高！有什么办法可以减少样本规模造成的影响，同时还能比较高效的进行实验估计？？？ “自助法（bootstrapping）”是一种比较好的解决方案（以“直接采样法”作为基础），给定包含m个样本的集合，对其采样生成$D\prime$，每次随机从D中抽取一个样本，放入$D\prime$中，然后再将样本放回D中，这样下一次仍有可能采集到该样本；重复此过程m此后，获的包含m个样本的数据集$D\prime$。在$D‘$中有些样本会重复出现，而有些则根本不出现。可以估算，样本在m次采样中都不被采到的概率是$(1- \frac{1}{m})^m$,去极限得到：$$\lim\limits_{m \mapsto \infty}{(1- \frac{1}{m})^m} \mapsto \frac{1}{e} \approx 0.368$$ 也就是说“自助法”中大概有 36.8% 的样本未出现在数据集 $D\prime$中。 将 $D\prime$ 作为训练集，将 $D\D\prime$作为测试集，这样实际评估的模型与期望评估的模型都是用m个训练样本。仍然有$\frac{1}{3}$的数据样本用于测试，这样的测试结果，也称“包外估计（out of bag estimate）”。 自助法对于数据集较小，在难以有效划分训练集、测试集时很有用。自助法能够产生多个训练集，这对于集成学习很有好处，然而，自助法产生数据的方式改变了初始数据集的分布，带来估计偏差 调参与最终模型大多数学习算法都有些参数（parameter）需要设置，参数配置不同导致的学习的模型性能往往有差别，因此除了对适用学习算法进行选择，还需对算法参数进行设定（即常说的“参数选择”）。而实际上机器学习通常涉及到两类参数，一类是超参数（算法的参数）；另一类是模型的参数，比如深度网络中每个节点的权值参数。 给定m个样本的数据集D，在模型评估与选择过程中由于需要留出一部分数据进行测试，实际上只用了一部分数据训练模型，在模型选择完成后，学习算法和参数配置就已经确定好，此时，应该使用D重新训练模型，使用所用m个样本，这是最终提交给用户的模型！ * 一般将模型在实际使用中遇到的数据称为 “测试数据”* 为了区分，模型评估与选择中用于评估的数据集称为“验证集（validation set）” 性能度量衡量模型泛化能力的评价标准，称为性能度量（performance measure），给定样例集$D={(x_1, y_2),(x_2, y_2),…,(x_n, y_n)}$ 其中 $y_i$ 是 样例 $x_i$ 的真实标记，要评估学习器 $f$ 的性能，就要把学习器预测结果 $f(x)$ 与真实标记 $y$ 进行比较。 * 回归任务最常用的性能度量是 “均方误差” (mean squared error). $$E(f;D) = \frac{1}{m} \sum_{i=1}^{m}(f(x_i)-y_i)^2$$ 跟一般的对于数据分布 D 和概率密度函数$p(·)$ 均方误差可表示为： $$E(f;D) = \int_{x \sim D} (f(x)-y)^2 p(x)dx$$ 错误率 与 精度* $\mathrm{II}(·)$ 指示函数，根据是否为真输出为0或1。 错误率 与 精度 是分类任务中最常用的两种性能度量，即适用于二分类任务、也适用于多分类任务。错误率是分类错误的样例占样本总数的比例： $$E(f;D) = \frac{1}{m}\sum_{i=1}^{m} \mathrm{II} (f(x_i) \neq y_i)$$ 相应的精度则定义为： $$\begin{equation}\begin{split}acc(f;D) &amp;= \frac{1}{m}\sum_{i=1}^{m} \mathrm{II} (f(x_i) = y_i)\\&amp;=1-E(f;D)\end{split}\end{equation}$$ 跟一般的对于数据分布 D 和概率密度函数$p(·)$ 错误率和精度可表示为：$$错误率：E(f;D) = \int_{x \sim D} \mathrm{II} (f(x) \neq y) p(x) dx$$ $$\begin{equation}\begin{split}精度：acc(f;D) &amp;= \int_{x \sim D} \mathrm{II} (f(x) = y) p(x) dx\\&amp;= 1- E(f;D)\end{split}\end{equation}$$ 查准率、 查全率、 与 F1错误率衡量了模型对样本的识别能力，比如一车西瓜，通过模型分类后，错误率能告诉我们有多少个瓜判别错误，但是如果实际问题更关心的是“挑出的瓜中有多少是好瓜，或者好瓜中有多少被挑了出来”。那错误率显然不满足情况，这时需要其他性能度量！ ###查准率（precision） ###查全率（召回率、recall） P-R图（P-R曲线） 完全包裹 面积 平衡点（Break-Even Point） ROC 与 AUC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日头条爬虫实习生面试]]></title>
      <url>%2F2017%2F04%2F26%2Finterview%2Finterview-toutiao-1%2F</url>
      <content type="text"><![CDATA[面试官先问了我的爬虫项目经验，对于爬虫的各种细节都问到了，还有截取非http的爬虫？应该比较少吧，第一次听说。感觉爬虫方面还是回答的比较好的。 后来问了我两个算法方面的问题： A、B两个有序（升序）数组，寻找去其中第k大的元素。 我的回答是“使用两个指示器指示数组末尾位置，比较相对应的位置元素大小，大的就往前移动，移动k次后，返回移动对应的元素”，然后面试官问时间复杂度，和空间复杂度，当时没反应过来，时间复杂度就是O(k)呀，空间复杂度，由于只需要额外3个元素存储指示信心，所以空间复杂度是O(3)。 A、B两人轮流下棋，棋盘是圆的，轮留下，棋盘没有格子，当棋盘满了，不能放棋子的人就输了，如何保证自己必赢。 答案很巧妙，当时没有想出来，“首先需要在棋盘中心位置下一子，以后，每次都在对手下棋位置关于圆心对称的地方放置棋子”，此法可保证必胜。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小米暑期软件研发工程师面试]]></title>
      <url>%2F2017%2F04%2F26%2Finterview%2Finterview-mi-1%2F</url>
      <content type="text"><![CDATA[简记一下小米的面试，一开始是个人介绍和项目介绍。目前发现问题是个人的介绍还是很简单，没有很好突出自己的优点，在项目中的一些难点，复杂点也没有向面试官介绍清楚，小米的面试官给人一种很亲切的感觉。后来就开始线上笔试，笔试很特殊，是以共享文档的方式考察个人的算法功底，面试官写一行，我回答一行。 题目大体是： 用链表表示一个数：123 表示为 1 -&gt; 2 -&gt; 3，给出两个数，求其和，结果也用链表形式返回。 比较简单的一道题目，将链表反转，进行相加操作后，返回结果即可， 值得我留意的是： 这里链表反转用3个指针就可以使得原链表反转，可以不用构建一个新链表 set类可以O(1)的复杂度进行查找 位图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习 绪论]]></title>
      <url>%2F2017%2F04%2F20%2FMachineLearning-1%2F</url>
      <content type="text"><![CDATA[《机器学习-周志华》笔记 第一章 什么是机器学习？人类能够从日常生活中观察事物的规律，总结而成经验，继而以经验辅助判断指导实践活动。获得经验的过程就是学习的过程。那么计算机能够产生对事物更深层次的理解吗？机器学习主要研究的内容是从 数据 中产生 模型 的算法，即学习算法（learning algorithm）。学习算法能够根据提供的经验数据产生模型，在面对新情况时以模型作为依据提供相应判断或产出。 【Machine Learning,Tom Mitchell 1997】给出了更形式化的定义：假设用P来评估计算机程序在任务类T上的性能，若一个程序通过利用经验E在T中任务上获得性能改善，则我们就说关于T和P，该程序对E进行了学习 基本术语 模型： “模型” 泛指从数据中学习得到的结果。 数据集： 一批数据的集合，数据集由样本构成。 示例(instance)、样本(sample)： 数据集合中的每一条记录称为示例(样本)，示例构成数据集。样本属性的个数d称为样本的” 维度 “(dimensionality), 具备了 标记(label) 的样本称为 样例(example) 。 属性(特征) [属性空间] [样本空间] [输入空间]： 反映事物或对象在某方面的表现或性质的事项，属性张成的空间称为” 属性空间 “、” 样本空间 “、” 输入空间 “。 学习(learning)、训练(training) [训练集]： 从数据中学的模型的过程称为” 学习 “、” 训练 “。训练过程使用的数据称为” 训练数据 “，其中每个样本称为” 训练样本 “，训练样本组成的集合称为” 训练集 “。 测试(testing) [测试集]： 学习模型后，对模型进行评估从而用一组新数据进行预测的过程称为” 测试 “，而这组新的数据称为 “ 测试集 “，被预测的样本称为 “ 测试样本 “ 假设(hypothesis): 学习得到的模型对应了关于数据的某种潜在的规律，因此也称 “假设”。模型有时也称 “学习器”。 分类、 回归： 若预测的目标是离散的，则学习任务称为”分类”；若目标是连续值，则学习任务称为”回归”。只涉及两个类别的称为”二分类”，通常称一类为” 正类 “、另一类为” 反类 “；涉及多个类别的分类称为 “ 多分类 “ 聚类： 将数据集上的样本分类若干组，每组称为” 簇 “。聚类过程中使用的数据样本通常不含有标记信息。 监督学习、无监督学习、半监督学习 泛化： 指学习得到的模型适用于新样本的能力。 假设空间归纳与演绎，是科学推理的两大基本手段。归纳指的是特殊到一般的泛化；演绎指的是一般到特殊的泛化。机器学习是从样例中学习，所以也称” 归纳学习 “。机械的记住” 训练样本 “的学习方式称为” 机械学习 “,只是简单的记住训练样本对于未遇见过的样本来预测效果会很差。考虑这样一个例子：选西瓜，可以根据根蒂、敲声、色泽综合判断西瓜是否是好瓜的情况。用布尔表达式为： $$ 好瓜\leftrightarrow(色泽=?)\vee(根蒂=?)\vee(敲声=?) $$ 更一般的情况应考虑析合范式: $$(A \vee B) \wedge (C \vee D)$$ 我们把学习过程看作是在所有假设组成的空间中进行搜索的过程，搜索目标是寻找与“训练集”匹配的假设。在西瓜例子中可以知道，色泽可以取“青绿”、“乌黑“ 2种取值，或色泽对好瓜根本没有影响（即其实是3种取值）；根蒂可以取“蜷缩”、“稍蜷”、“硬挺” 3种取值，也可能根蒂对好瓜没有影响（即其实是4种取值）；敲声可取“浊响”、“清脆” 2种取值，也可能敲声对好瓜也无影响（也即其实是3种取值）；也可能根本不存在好瓜这一食物。所如果假设色泽、根蒂、敲声的各有3、2、2种取值，计算时每个取值需要附加上 无影响选择以可以知道面试的假设空间大小为: $$ 4 \times 3 \times 3 + 1 = 37$$ 基于训练集进行训练得到与训练集一致的假设（能够在训练集上作出正确判断、预测），就是学习的结果。在现实问题中可能面临一个很大的假设空间，但是学习过程是基于样本集进行的，因此很可能出现多个假设与训练集一只，即存在一个与训练集一致的“假设集合”，称之为“ 版本空间 ”。 训练集合： 编号 色泽 根蒂 敲声 好瓜 1 青绿 蜷缩 浊响 是 2 乌黑 蜷缩 浊响 是 3 青绿 硬挺 清脆 否 4 乌黑 稍蜷 沉闷 否 西瓜问题的版本空间，现在具有3个假设与训练集一致；对于训练集而言，无法判定哪一个假设更加好。然而对于具体的学习算法而言，必须给出一个模型。这时算法本身的“ 偏好 ”就会其到关键作用。如果算法喜欢尽可能“特殊”的模型，则它会选择 $$ 好瓜\leftrightarrow(色泽=\star)\vee(根蒂=蜷缩)\vee(敲声=浊响) $$ 但如果算法喜欢更加一般的模型，并且由于某种原因它更加愿意“相信”根蒂，则它会选择：$$ 好瓜\leftrightarrow(色泽=\star)\vee(根蒂=蜷缩)\vee(敲声=\star) $$ 机器学习算法在学习过程中对某种类型假设的偏好，称为“归纳偏好”，或简称 “ 偏好 ”， 任何一个有效的机器学习算法必有其归纳偏好，否则它将被假设空间中看似在训练集上“等效”的算法所迷惑，而无法产生确定的学习结果。可以想像，对于一个新瓜，我们的学习算法随机挑选版本空间中的一个假设时而告诉它是好瓜，时而告诉它是坏瓜，这样的学习显然没有任何意义。关于“ 归纳偏好 ”使用回归学习图更加直观，对于下图的点集，要学的一个与训练集一致的模型，相当于找到一条穿过所有样本点的曲线。显然，对有限个样本点组成的训练集，存在很多条与其一致。我们的学习算法必须有某种偏好，才能产出他认为“正确”的模型。归纳偏好可以看作是在假设空间中对假设进行选择的启发式，或“价值观”。 “ 奥卡姆剃刀原则 ”是常用的一种方法，奥卡姆剃刀原则表示“ 若有多个假设与观察一致，则选择最简单的那个 ”。 很多时候，算法A在某些问题上表现比算法B更加好，而算法B在某些问题上表现比算法A更好。证明过程 P8 机器学习发展历程符号主义，逻辑推理1963 年 “逻辑理论家”程序 证明了罗素和怀特海的 《数学原理》 中的52条定理 知识工程20世纪 70年代中期，人工智能进入“知识期”，专家系统。 连接主义20世纪 50年代 罗森布莱特 的 感知机。 神经网络、深度学习等。 统计学习20世界90年代中期，统计学习占据主导地位。 行为主义来源于控制论，又称进化主义，其原理为控制论及感知-动作型控制系统。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5_11 俄罗斯方块]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5%2FPyQt5-11%2F</url>
      <content type="text"><![CDATA[俄罗斯方块俄罗斯方块是最流行的电脑游戏之一，1985年俄罗斯开发者 Alexey Pajitnov 开发出最初的原型。 六种基本形状 S 形块 Z 形块 T 形块 L 形块 镜像L形块 线形块每种形状都有四个方块组成，形状从上往下掉落，可以通过旋转改变形状的姿态，尽可能适应填满一行。如果填满一行，则该行删除获得相应分数。累积到顶部则游戏结束。 开发通过绘图API绘制形状，电脑游戏背后都有一些数学模型，俄罗斯方块也是如此。一些思路 使用QBasicTimer() 创建游戏循环 绘制形状 形状以方块移动，而不是像素。 模型化背板为数字的列表。 代码由四个类组成：Tetris, Board, Tetrominoe 和 Shape。Tetris 类构建游戏，Board负责游戏逻辑，Tetrominoe表示所有的方块名字，Shape类表示方块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This is a Tetris game clone.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sys, randomfrom PyQt5.QtWidgets import QMainWindow, QFrame, QDesktopWidget, QApplicationfrom PyQt5.QtCore import Qt, QBasicTimer, pyqtSignalfrom PyQt5.QtGui import QPainter, QColor class Tetris(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.tboard = Board(self) self.setCentralWidget(self.tboard) self.statusbar = self.statusBar() self.tboard.msg2Statusbar[str].connect(self.statusbar.showMessage) self.tboard.start() self.resize(180, 380) self.center() self.setWindowTitle('Tetris') self.show() def center(self): screen = QDesktopWidget().screenGeometry() size = self.geometry() self.move((screen.width()-size.width())/2, (screen.height()-size.height())/2) class Board(QFrame): msg2Statusbar = pyqtSignal(str) BoardWidth = 10 BoardHeight = 22 Speed = 300 def __init__(self, parent): super().__init__(parent) self.initBoard() def initBoard(self): self.timer = QBasicTimer() self.isWaitingAfterLine = False self.curX = 0 self.curY = 0 self.numLinesRemoved = 0 self.board = [] self.setFocusPolicy(Qt.StrongFocus) self.isStarted = False self.isPaused = False self.clearBoard() def shapeAt(self, x, y): return self.board[(y * Board.BoardWidth) + x] def setShapeAt(self, x, y, shape): self.board[(y * Board.BoardWidth) + x] = shape def squareWidth(self): return self.contentsRect().width() // Board.BoardWidth def squareHeight(self): return self.contentsRect().height() // Board.BoardHeight def start(self): if self.isPaused: return self.isStarted = True self.isWaitingAfterLine = False self.numLinesRemoved = 0 self.clearBoard() self.msg2Statusbar.emit(str(self.numLinesRemoved)) self.newPiece() self.timer.start(Board.Speed, self) def pause(self): if not self.isStarted: return self.isPaused = not self.isPaused if self.isPaused: self.timer.stop() self.msg2Statusbar.emit("paused") else: self.timer.start(Board.Speed, self) self.msg2Statusbar.emit(str(self.numLinesRemoved)) self.update() def paintEvent(self, event): painter = QPainter(self) rect = self.contentsRect() boardTop = rect.bottom() - Board.BoardHeight * self.squareHeight() for i in range(Board.BoardHeight): for j in range(Board.BoardWidth): shape = self.shapeAt(j, Board.BoardHeight - i - 1) if shape != Tetrominoe.NoShape: self.drawSquare(painter, rect.left() + j * self.squareWidth(), boardTop + i * self.squareHeight(), shape) if self.curPiece.shape() != Tetrominoe.NoShape: for i in range(4): x = self.curX + self.curPiece.x(i) y = self.curY - self.curPiece.y(i) self.drawSquare(painter, rect.left() + x * self.squareWidth(), boardTop + (Board.BoardHeight - y - 1) * self.squareHeight(), self.curPiece.shape()) def keyPressEvent(self, event): if not self.isStarted or self.curPiece.shape() == Tetrominoe.NoShape: super(Board, self).keyPressEvent(event) return key = event.key() if key == Qt.Key_P: self.pause() return if self.isPaused: return elif key == Qt.Key_Left: self.tryMove(self.curPiece, self.curX - 1, self.curY) elif key == Qt.Key_Right: self.tryMove(self.curPiece, self.curX + 1, self.curY) elif key == Qt.Key_Down: self.tryMove(self.curPiece.rotateRight(), self.curX, self.curY) elif key == Qt.Key_Up: self.tryMove(self.curPiece.rotateLeft(), self.curX, self.curY) elif key == Qt.Key_Space: self.dropDown() elif key == Qt.Key_D: self.oneLineDown() else: super(Board, self).keyPressEvent(event) def timerEvent(self, event): if event.timerId() == self.timer.timerId(): if self.isWaitingAfterLine: self.isWaitingAfterLine = False self.newPiece() else: self.oneLineDown() else: super(Board, self).timerEvent(event) def clearBoard(self): for i in range(Board.BoardHeight * Board.BoardWidth): self.board.append(Tetrominoe.NoShape) def dropDown(self): newY = self.curY while newY &gt; 0: if not self.tryMove(self.curPiece, self.curX, newY - 1): break newY -= 1 self.pieceDropped() def oneLineDown(self): if not self.tryMove(self.curPiece, self.curX, self.curY - 1): self.pieceDropped() def pieceDropped(self): for i in range(4): x = self.curX + self.curPiece.x(i) y = self.curY - self.curPiece.y(i) self.setShapeAt(x, y, self.curPiece.shape()) self.removeFullLines() if not self.isWaitingAfterLine: self.newPiece() def removeFullLines(self): numFullLines = 0 rowsToRemove = [] for i in range(Board.BoardHeight): n = 0 for j in range(Board.BoardWidth): if not self.shapeAt(j, i) == Tetrominoe.NoShape: n = n + 1 if n == 10: rowsToRemove.append(i) rowsToRemove.reverse() for m in rowsToRemove: for k in range(m, Board.BoardHeight): for l in range(Board.BoardWidth): self.setShapeAt(l, k, self.shapeAt(l, k + 1)) numFullLines = numFullLines + len(rowsToRemove) if numFullLines &gt; 0: self.numLinesRemoved = self.numLinesRemoved + numFullLines self.msg2Statusbar.emit(str(self.numLinesRemoved)) self.isWaitingAfterLine = True self.curPiece.setShape(Tetrominoe.NoShape) self.update() def newPiece(self): self.curPiece = Shape() self.curPiece.setRandomShape() self.curX = Board.BoardWidth // 2 + 1 self.curY = Board.BoardHeight - 1 + self.curPiece.minY() if not self.tryMove(self.curPiece, self.curX, self.curY): self.curPiece.setShape(Tetrominoe.NoShape) self.timer.stop() self.isStarted = False self.msg2Statusbar.emit("Game over") def tryMove(self, newPiece, newX, newY): for i in range(4): x = newX + newPiece.x(i) y = newY - newPiece.y(i) if x &lt; 0 or x &gt;= Board.BoardWidth or y &lt; 0 or y &gt;= Board.BoardHeight: return False if self.shapeAt(x, y) != Tetrominoe.NoShape: return False self.curPiece = newPiece self.curX = newX self.curY = newY self.update() return True def drawSquare(self, painter, x, y, shape): colorTable = [0x000000, 0xCC6666, 0x66CC66, 0x6666CC, 0xCCCC66, 0xCC66CC, 0x66CCCC, 0xDAAA00] color = QColor(colorTable[shape]) painter.fillRect(x + 1, y + 1, self.squareWidth() - 2, self.squareHeight() - 2, color) painter.setPen(color.lighter()) painter.drawLine(x, y + self.squareHeight() - 1, x, y) painter.drawLine(x, y, x + self.squareWidth() - 1, y) painter.setPen(color.darker()) painter.drawLine(x + 1, y + self.squareHeight() - 1, x + self.squareWidth() - 1, y + self.squareHeight() - 1) painter.drawLine(x + self.squareWidth() - 1, y + self.squareHeight() - 1, x + self.squareWidth() - 1, y + 1)class Tetrominoe(object): NoShape = 0 ZShape = 1 SShape = 2 LineShape = 3 TShape = 4 SquareShape = 5 LShape = 6 MirroredLShape = 7class Shape(object): coordsTable = ( ((0, 0), (0, 0), (0, 0), (0, 0)), ((0, -1), (0, 0), (-1, 0), (-1, 1)), ((0, -1), (0, 0), (1, 0), (1, 1)), ((0, -1), (0, 0), (0, 1), (0, 2)), ((-1, 0), (0, 0), (1, 0), (0, 1)), ((0, 0), (1, 0), (0, 1), (1, 1)), ((-1, -1), (0, -1), (0, 0), (0, 1)), ((1, -1), (0, -1), (0, 0), (0, 1)) ) def __init__(self): self.coords = [[0,0] for i in range(4)] self.pieceShape = Tetrominoe.NoShape self.setShape(Tetrominoe.NoShape) def shape(self): return self.pieceShape def setShape(self, shape): table = Shape.coordsTable[shape] for i in range(4): for j in range(2): self.coords[i][j] = table[i][j] self.pieceShape = shape def setRandomShape(self): self.setShape(random.randint(1, 7)) def x(self, index): return self.coords[index][0] def y(self, index): return self.coords[index][1] def setX(self, index, x): self.coords[index][0] = x def setY(self, index, y): self.coords[index][1] = y def minX(self): m = self.coords[0][0] for i in range(4): m = min(m, self.coords[i][0]) return m def maxX(self): m = self.coords[0][0] for i in range(4): m = max(m, self.coords[i][0]) return m def minY(self): m = self.coords[0][1] for i in range(4): m = min(m, self.coords[i][1]) return m def maxY(self): m = self.coords[0][1] for i in range(4): m = max(m, self.coords[i][1]) return m def rotateLeft(self): if self.pieceShape == Tetrominoe.SquareShape: return self result = Shape() result.pieceShape = self.pieceShape for i in range(4): result.setX(i, self.y(i)) result.setY(i, -self.x(i)) return result def rotateRight(self): if self.pieceShape == Tetrominoe.SquareShape: return self result = Shape() result.pieceShape = self.pieceShape for i in range(4): result.setX(i, -self.y(i)) result.setY(i, self.x(i)) return resultif __name__ == '__main__': app = QApplication([]) tetris = Tetris() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5_10 自定义部件【Custom widgets in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5%2FPyQt5-10%2F</url>
      <content type="text"><![CDATA[PyQt5 有一系列空间，然而开发者可能有某些特殊的需要。通常只提供最基本的部件，比如：按钮、文本、滚动条等。如果需要更特殊的部件，可以自行创建。通过绘图工具自定义部件，两种可能的方法，开发者可以定义、增强部件 或者自己创建一个部件。 Burning widget123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a custom widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QSlider, QApplication, QHBoxLayout, QVBoxLayout)from PyQt5.QtCore import QObject, Qt, pyqtSignalfrom PyQt5.QtGui import QPainter, QFont, QColor, QPenclass Communicate(QObject): updateBW = pyqtSignal(int)class BurningWidget(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setMinimumSize(1, 30) self.value = 75 self.num = [75, 150, 225, 300, 375, 450, 525, 600, 675] def setValue(self, value): self.value = value def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawWidget(qp) qp.end() def drawWidget(self, qp): font = QFont('Serif', 7, QFont.Light) qp.setFont(font) size = self.size() w = size.width() h = size.height() step = int(round(w / 10.0)) till = int(((w / 750.0) * self.value)) full = int(((w / 750.0) * 700)) if self.value &gt;= 700: qp.setPen(QColor(255, 255, 255)) qp.setBrush(QColor(255, 255, 184)) qp.drawRect(0, 0, full, h) qp.setPen(QColor(255, 175, 175)) qp.setBrush(QColor(255, 175, 175)) qp.drawRect(full, 0, till-full, h) else: qp.setPen(QColor(255, 255, 255)) qp.setBrush(QColor(255, 255, 184)) qp.drawRect(0, 0, till, h) pen = QPen(QColor(20, 20, 20), 1, Qt.SolidLine) qp.setPen(pen) qp.setBrush(Qt.NoBrush) qp.drawRect(0, 0, w-1, h-1) j = 0 for i in range(step, 10*step, step): qp.drawLine(i, 0, i, 5) metrics = qp.fontMetrics() fw = metrics.width(str(self.num[j])) qp.drawText(i-fw/2, h/2, str(self.num[j])) j = j + 1 class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): sld = QSlider(Qt.Horizontal, self) sld.setFocusPolicy(Qt.NoFocus) sld.setRange(1, 750) sld.setValue(75) sld.setGeometry(30, 40, 150, 30) self.c = Communicate() self.wid = BurningWidget() self.c.updateBW[int].connect(self.wid.setValue) sld.valueChanged[int].connect(self.changeValue) hbox = QHBoxLayout() hbox.addWidget(self.wid) vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) self.setLayout(vbox) self.setGeometry(300, 300, 390, 210) self.setWindowTitle('Burning widget') self.show() def changeValue(self, value): self.c.updateBW.emit(value) self.wid.repaint() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-9 绘图 【Painting in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5%2FPyQt5-9%2F</url>
      <content type="text"><![CDATA[PyQt5 绘图系统能够渲染矢量图、图片、艺术字。绘图对于改变或增强现有部件功能很重要，使用内建的绘图api进行绘制。绘制由paintEvent()方法完成。绘制代码放置在QPainter对象的begin()方法和end()方法中。 绘制文本【Drawing text】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we draw text in Russian azbuka.author: Jan Bodnarwebsite: zetcode.com last edited: September 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QFontfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.text = u'\u041b\u0435\u0432 \u041d\u0438\u043a\u043e\u043b\u0430\\u0435\u0432\u0438\u0447 \u0422\u043e\u043b\u0441\u0442\u043e\u0439: \n\\u0410\u043d\u043d\u0430 \u041a\u0430\u0440\u0435\u043d\u0438\u043d\u0430' self.setGeometry(300, 300, 280, 170) self.setWindowTitle('Draw text') self.show() def paintEvent(self, event): qp = QPainter() qp.begin(self) self.drawText(event, qp) qp.end() def drawText(self, event, qp): qp.setPen(QColor(168, 34, 3)) qp.setFont(QFont('Decorative', 10)) qp.drawText(event.rect(), Qt.AlignCenter, self.text) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 画点 【Drawing points】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In the example, we draw randomly 1000 red points on the window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sys, randomfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QPenfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 280, 170) self.setWindowTitle('Points') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawPoints(qp) qp.end() def drawPoints(self, qp): qp.setPen(Qt.red) size = self.size() for i in range(1000): x = random.randint(1, size.width()-1) y = random.randint(1, size.height()-1) qp.drawPoint(x, y) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 颜色 【colours】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example draws three rectangles in three#different colours. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QBrushclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 350, 100) self.setWindowTitle('Colours') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawRectangles(qp) qp.end() def drawRectangles(self, qp): col = QColor(0, 0, 0) col.setNamedColor('#d4d4d4') qp.setPen(col) qp.setBrush(QColor(200, 0, 0)) qp.drawRect(10, 15, 90, 60) qp.setBrush(QColor(255, 80, 0, 160)) qp.drawRect(130, 15, 90, 60) qp.setBrush(QColor(25, 0, 90, 200)) qp.drawRect(250, 15, 90, 60) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QPenQPen 是基本的图形对象，可以用户画线、曲线、举行的轮廓、阴影、几何图形和其他形状。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example we draw 6 lines usingdifferent pen styles. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QPenfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 280, 270) self.setWindowTitle('Pen styles') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawLines(qp) qp.end() def drawLines(self, qp): pen = QPen(Qt.black, 2, Qt.SolidLine) qp.setPen(pen) qp.drawLine(20, 40, 250, 40) pen.setStyle(Qt.DashLine) qp.setPen(pen) qp.drawLine(20, 80, 250, 80) pen.setStyle(Qt.DashDotLine) qp.setPen(pen) qp.drawLine(20, 120, 250, 120) pen.setStyle(Qt.DotLine) qp.setPen(pen) qp.drawLine(20, 160, 250, 160) pen.setStyle(Qt.DashDotDotLine) qp.setPen(pen) qp.drawLine(20, 200, 250, 200) pen.setStyle(Qt.CustomDashLine) pen.setDashPattern([1, 4, 5, 4]) qp.setPen(pen) qp.drawLine(20, 240, 250, 240) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QBrushQBrush 是基本的图形对象，用于图形的背景绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example draws 9 rectangles in differentbrush styles.author: Jan Bodnarwebsite: zetcode.com last edited: July 2016"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QBrushfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 355, 280) self.setWindowTitle('Brushes') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawBrushes(qp) qp.end() def drawBrushes(self, qp): brush = QBrush(Qt.SolidPattern) qp.setBrush(brush) qp.drawRect(10, 15, 90, 60) brush.setStyle(Qt.Dense1Pattern) qp.setBrush(brush) qp.drawRect(130, 15, 90, 60) brush.setStyle(Qt.Dense2Pattern) qp.setBrush(brush) qp.drawRect(250, 15, 90, 60) brush.setStyle(Qt.DiagCrossPattern) qp.setBrush(brush) qp.drawRect(10, 105, 90, 60) brush.setStyle(Qt.Dense5Pattern) qp.setBrush(brush) qp.drawRect(130, 105, 90, 60) brush.setStyle(Qt.Dense6Pattern) qp.setBrush(brush) qp.drawRect(250, 105, 90, 60) brush.setStyle(Qt.HorPattern) qp.setBrush(brush) qp.drawRect(10, 195, 90, 60) brush.setStyle(Qt.VerPattern) qp.setBrush(brush) qp.drawRect(130, 195, 90, 60) brush.setStyle(Qt.BDiagPattern) qp.setBrush(brush) qp.drawRect(250, 195, 90, 60) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-8 小部件II 【widgets II】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5%2FPyQt5-8%2F</url>
      <content type="text"><![CDATA[widgets 用法例子，不含解释。 QPixmap在屏幕上显示图片。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we dispay an imageon the window. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QHBoxLayout, QLabel, QApplication)from PyQt5.QtGui import QPixmapclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) pixmap = QPixmap("redrock.png") lbl = QLabel(self) lbl.setPixmap(pixmap) hbox.addWidget(lbl) self.setLayout(hbox) self.move(300, 200) self.setWindowTitle('Red Rock') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QLineEdit单行编辑框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows text which is entered in a QLineEditin a QLabel widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel(self) qle = QLineEdit(self) qle.move(60, 100) self.lbl.move(60, 40) qle.textChanged[str].connect(self.onChanged) self.setGeometry(300, 300, 280, 170) self.setWindowTitle('QLineEdit') self.show() def onChanged(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QSplitter将区域分割，切分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example showshow to use QSplitter widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QHBoxLayout, QFrame, QSplitter, QStyleFactory, QApplication)from PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) topleft = QFrame(self) topleft.setFrameShape(QFrame.StyledPanel) topright = QFrame(self) topright.setFrameShape(QFrame.StyledPanel) bottom = QFrame(self) bottom.setFrameShape(QFrame.StyledPanel) splitter1 = QSplitter(Qt.Horizontal) splitter1.addWidget(topleft) splitter1.addWidget(topright) splitter2 = QSplitter(Qt.Vertical) splitter2.addWidget(splitter1) splitter2.addWidget(bottom) hbox.addWidget(splitter2) self.setLayout(hbox) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('QSplitter') self.show() def onChanged(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QComboBox下拉列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows how to use a QComboBox widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QComboBox, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel("Ubuntu", self) combo = QComboBox(self) combo.addItem("Ubuntu") combo.addItem("Mandriva") combo.addItem("Fedora") combo.addItem("Arch") combo.addItem("Gentoo") combo.move(50, 50) self.lbl.move(50, 150) combo.activated[str].connect(self.onActivated) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('QComboBox') self.show() def onActivated(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-7 小部件 【widgets】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5%2FPyQt5-7%2F</url>
      <content type="text"><![CDATA[小部件 是应用的基础构建块。PyQt5 具备一系列不同的小部件，包括：按钮、多选按钮、滚动条、列表。此教程中，将探讨几个常用的部件，QCheckBox、ToggleButton、QSlider、QProgressBar、QCalendarWidget。 widgets 用法例子，不含解释 QCheckBox多选按钮，具备开启、关闭两种状态。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, a QCheckBox widgetis used to toggle the title of a window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QCheckBox, QApplicationfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): cb = QCheckBox('Show title', self) cb.move(20, 20) cb.toggle() cb.stateChanged.connect(self.changeTitle) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('QCheckBox') self.show() def changeTitle(self, state): if state == Qt.Checked: self.setWindowTitle('QCheckBox') else: self.setWindowTitle('') if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) Toggle buttonToggle button 是具备press和not press 两种状态的按钮。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create three toggle buttons.They will control the background color of a QFrame. Author: Jan BodnarWebsite: zetcode.com Last edited: November 2016"""import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QApplication)from PyQt5.QtGui import QColorclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.col = QColor(0, 0, 0) redb = QPushButton('Red', self) redb.setCheckable(True) redb.move(10, 10) redb.clicked[bool].connect(self.setColor) greenb = QPushButton('Green', self) greenb.setCheckable(True) greenb.move(10, 60) greenb.clicked[bool].connect(self.setColor) blueb = QPushButton('Blue', self) blueb.setCheckable(True) blueb.move(10, 110) blueb.clicked[bool].connect(self.setColor) self.square = QFrame(self) self.square.setGeometry(150, 20, 100, 100) self.square.setStyleSheet("QWidget &#123; background-color: %s &#125;" % self.col.name()) self.setGeometry(300, 300, 280, 170) self.setWindowTitle('Toggle button') self.show() def setColor(self, pressed): source = self.sender() if pressed: val = 255 else: val = 0 if source.text() == "Red": self.col.setRed(val) elif source.text() == "Green": self.col.setGreen(val) else: self.col.setBlue(val) self.square.setStyleSheet("QFrame &#123; background-color: %s &#125;" % self.col.name()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QSliderQSlider 滚动条 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a QSlider widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QSlider, QLabel, QApplication)from PyQt5.QtCore import Qtfrom PyQt5.QtGui import QPixmapclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): sld = QSlider(Qt.Horizontal, self) sld.setFocusPolicy(Qt.NoFocus) sld.setGeometry(30, 40, 100, 30) sld.valueChanged[int].connect(self.changeValue) self.label = QLabel(self) self.label.setPixmap(QPixmap('mute.png')) self.label.setGeometry(160, 40, 80, 30) self.setGeometry(300, 300, 280, 170) self.setWindowTitle('QSlider') self.show() def changeValue(self, value): if value == 0: self.label.setPixmap(QPixmap('mute.png')) elif value &gt; 0 and value &lt;= 30: self.label.setPixmap(QPixmap('min.png')) elif value &gt; 30 and value &lt; 80: self.label.setPixmap(QPixmap('med.png')) else: self.label.setPixmap(QPixmap('max.png')) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QProgressBar进度条 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a QProgressBar widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QProgressBar, QPushButton, QApplication)from PyQt5.QtCore import QBasicTimerclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.pbar = QProgressBar(self) self.pbar.setGeometry(30, 40, 200, 25) self.btn = QPushButton('Start', self) self.btn.move(40, 80) self.btn.clicked.connect(self.doAction) self.timer = QBasicTimer() self.step = 0 self.setGeometry(300, 300, 280, 170) self.setWindowTitle('QProgressBar') self.show() def timerEvent(self, e): if self.step &gt;= 100: self.timer.stop() self.btn.setText('Finished') return self.step = self.step + 1 self.pbar.setValue(self.step) def doAction(self): if self.timer.isActive(): self.timer.stop() self.btn.setText('Start') else: self.timer.start(100, self) self.btn.setText('Stop') if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QCalendarWidget日期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a QCalendarWidget widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QCalendarWidget, QLabel, QApplication)from PyQt5.QtCore import QDateclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): cal = QCalendarWidget(self) cal.setGridVisible(True) cal.move(20, 20) cal.clicked[QDate].connect(self.showDate) self.lbl = QLabel(self) date = cal.selectedDate() self.lbl.setText(date.toString()) self.lbl.move(130, 260) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('Calendar') self.show() def showDate(self, date): self.lbl.setText(date.toString()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-6 对话框 【Dialogs in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5%2FPyQt5-6%2F</url>
      <content type="text"><![CDATA[对话框窗口 或 对话框 是现代GUI应用中不可或缺的部分。对话框是人之间的对话，在计算机中，对话框是用于与应用交互的窗口。对话框用于输入数据、定义数据、改变应用设置等。 QInputDialogQInputDialog 提供简便地从用户获取单值的方法。输入值可以是string、数字 或 列表的一项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we receive data froma QInputDialog dialog. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QLineEdit, QInputDialog, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.btn = QPushButton('Dialog', self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) self.le = QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Input dialog') self.show() def showDialog(self): text, ok = QInputDialog.getText(self, 'Input Dialog', 'Enter your name:') if ok: self.le.setText(str(text)) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QColorDialog用于选择颜色的对话框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we select a color valuefrom the QColorDialog and change the backgroundcolor of a QFrame widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QColorDialog, QApplication)from PyQt5.QtGui import QColorclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): col = QColor(0, 0, 0) self.btn = QPushButton('Dialog', self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) self.frm = QFrame(self) self.frm.setStyleSheet("QWidget &#123; background-color: %s &#125;" % col.name()) self.frm.setGeometry(130, 22, 100, 100) self.setGeometry(300, 300, 250, 180) self.setWindowTitle('Color dialog') self.show() def showDialog(self): col = QColorDialog.getColor() if col.isValid(): self.frm.setStyleSheet("QWidget &#123; background-color: %s &#125;" % col.name()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QFontDialog字体对话框 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we select a font nameand change the font of a label. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QVBoxLayout, QPushButton, QSizePolicy, QLabel, QFontDialog, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): vbox = QVBoxLayout() btn = QPushButton('Dialog', self) btn.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed) btn.move(20, 20) vbox.addWidget(btn) btn.clicked.connect(self.showDialog) self.lbl = QLabel('Knowledge only matters', self) self.lbl.move(130, 20) vbox.addWidget(self.lbl) self.setLayout(vbox) self.setGeometry(300, 300, 250, 180) self.setWindowTitle('Font dialog') self.show() def showDialog(self): font, ok = QFontDialog.getFont() if ok: self.lbl.setFont(font) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QFileDialog文件对话框，选择文件或路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we select a file with aQFileDialog and display its contentsin a QTextEdit.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QMainWindow, QTextEdit, QAction, QFileDialog, QApplication)from PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.textEdit = QTextEdit() self.setCentralWidget(self.textEdit) self.statusBar() openFile = QAction(QIcon('open.png'), 'Open', self) openFile.setShortcut('Ctrl+O') openFile.setStatusTip('Open new File') openFile.triggered.connect(self.showDialog) menubar = self.menuBar() fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(openFile) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('File dialog') self.show() def showDialog(self): fname = QFileDialog.getOpenFileName(self, 'Open file', '/home') if fname[0]: f = open(fname[0], 'r') with f: data = f.read() self.textEdit.setText(data) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-5 事件和信号【Events and signals in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5%2FPyQt5-5%2F</url>
      <content type="text"><![CDATA[这部分的将介绍PyQt5应用中的事件和信号处理。 事件【Events】所有的 GUI 应用都是事件驱动的。事件主要是由应用的用户产生，也可通过其他方法产生，比如：英特网连接、窗口管理器、定时器。当调用应用的exec_() 方法，应用进入主循环，主循环接受事件送往对应的处理对象。 事件模型中，三个组成部分： 事件源 事件对象 事件目标 事件源是状态改变的对象，由其产生事件。事件对象（事件）代表事件源的状态改变。事件目标是需要被通知发生变化的对象。事件源将事件处理委托给事件目标 PyQt5 使用独特的信号、槽机制处理事件。信号、槽用于与对象通信，当事件发生时便产生一个信号，槽可以是Python可调用对象。当信号产生时，其对应连接的槽将被调用。 信号、槽【Signals &amp; slots】例子：在PyQt5 中使用信号、槽1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we connect a signalof a QSlider to a slot of a QLCDNumber. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import (QWidget, QLCDNumber, QSlider, QVBoxLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lcd = QLCDNumber(self) sld = QSlider(Qt.Horizontal, self) vbox = QVBoxLayout() vbox.addWidget(lcd) vbox.addWidget(sld) self.setLayout(vbox) sld.valueChanged.connect(lcd.display) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Signal &amp; slot') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 例子中含有QLCDNumber 和 QSlider ，通过此句代码拖动滚动条改变lcd的显示。 1sld.valueChanged.connect(lcd.display) 将 valueChanged 信号与 Slider display 槽函数绑定。 发送者是发送信号的对象。接受者是接受信号的对象，槽是对信号做出反应的方法。 实现事件处理器 【Reimplementing event handler】PyQt5 中的事件处理经常需要重新实现事件处理器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we reimplement an event handler. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import QWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Event handler') self.show() def keyPressEvent(self, e): if e.key() == Qt.Key_Escape: self.close() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 实现了按键处理器，keyPressEvent 事件发送者 【Event sender】某些时候，知道信号的发送者很有帮助，因此PqQt5提供了sender()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we determine the event senderobject.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QPushButton, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): btn1 = QPushButton("Button 1", self) btn1.move(30, 50) btn2 = QPushButton("Button 2", self) btn2.move(150, 50) btn1.clicked.connect(self.buttonClicked) btn2.clicked.connect(self.buttonClicked) self.statusBar() self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Event sender') self.show() def buttonClicked(self): sender = self.sender() self.statusBar().showMessage(sender.text() + ' was pressed') if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 本例中有两个按钮，buttonClicked()方法通过sender确定是谁发生了点击事件。 触发信号【Emitting signals】展示如何自定义触发信号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we show how to emit asignal. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtCore import pyqtSignal, QObjectfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Communicate(QObject): closeApp = pyqtSignal() class Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.c = Communicate() self.c.closeApp.connect(self.close) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Emit signal') self.show() def mousePressEvent(self, event): self.c.closeApp.emit() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 创建一个 closeApp 信号，当鼠标键入时信号触发。此信号与close槽方法相连。 12self.c = Communicate()self.c.closeApp.connect(self.close)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[machine_learning]]></title>
      <url>%2F2017%2F04%2F14%2Fmachine-learning%2F</url>
      <content type="text"><![CDATA[normalization、standardization、regularization 定义区别http://blog.csdn.net/zyf89531/article/details/45922151 feature maphttps://www.zhihu.com/question/31318081 local response normalizationhttps://www.quora.com/What-is-local-response-normalization]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯面试]]></title>
      <url>%2F2017%2F04%2F11%2Finterview%2Finterview-tencent-1%2F</url>
      <content type="text"><![CDATA[早上大概9:30到的面试现场，签到等候的时候，心里在默默复习面试可能常问的问题。大概10:15分开始进去面试。一开始看到面试官，心情比较紧张，也不知到待会儿面试官会问我些什么呢。谨慎的递上简历后，简历官看了下我的简历。开始问我项目经历，科研方面的问题，还好都是自己做过的东西，介绍起来很轻松，怎么做的怎么说就是了。后来问了下学习和算法，面试官还想考察下我的代码功底，可惜，有些项目没有传到github上。 面试官对机器人挺感兴趣的，谈话中涉及到很多机器人方面的内容，还有机器学习上的一些问题。面试官感觉很亲切，像大哥哥一样。体验很好的一次面试。 update. 后来聊天发现这面试官来套我话的。。。被套路了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统知识点]]></title>
      <url>%2F2017%2F04%2F10%2Finterview%2Fos-basics-for-interview%2F</url>
      <content type="text"><![CDATA[操作系统部分进程、线程、协程、管程 概念和区别线程共享堆，同一内存空间 进程间通信 文件、锁 管道（半双工、父子进程间使用） 命名管道fifo（半双工、可以在无亲缘关系进程间通信） 信号量 信号 消息队列 共享内存 （只有映射为0时，内核才删除共享内存） 套接字 进程同步和互斥### 临界区 和 mutex 临界区只能在同一进程的线程中使用达到互斥，mutex可以在进程间使用达到互斥 临界区 是一段代码 锁、信号量、开关中断(硬件级)、管程 死锁概念中断 分类：软终端、硬中断 中断处理机制 请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回。 父子进程共享、fork 写时复制 共享代码段 数据空间、堆栈不同 文件指针 实际用户ID、实际组ID、有效用户ID、有效组ID 添加组ID、进程组ID、会话ID、控制终端 当前工作目录、根目录、文件屏蔽字、信号屏蔽和排列、环境变量、共享存储段。 ## 页式管理、段式管理、段页式管理。 数据库范式 1-范式 属性值不可再分裂成更小的部分 2-范式 1-范式的基础上，每个属性都依赖于关系模式R中的某个候选键 3-范式 消除了传递依赖的2-范式 BCNF范式 在1-范式的基础上，消除了传递依赖，即每个属性不传递依赖于R的候选键 函数依赖 平凡依赖 X→Y， Y包含X 非平凡依赖 X→Y， Y不包含X 多值依赖 设R(U)是属性集U上的一个关系模式。X，Y，Z是的U的子集,并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r,给定的一对(x，z)值有一组Y的值，这组值仅仅决定于x值而与z值无关。 平凡多值依赖 ，当z为空 非平凡多值依赖 游标（回滚操作）触发器 事前触发器、事后触发器 语句级出发、行级触发 SQL注入索引计算机网络TCP、UDP 区别 TCP 有连接、可靠的字节流服务、超时重发、检验数据、流量控制。 UDP 数据报协议、不可靠 tcp 特点 快重传、慢启动、超时重传 TCP 3次握手 TCP 4次挥手 设计模式 软件测试 黑盒测试白盒测试面向对象小点 结构体对齐问题，sizeof() 内联函数 宏只是简单的替换]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java基础知识点目录]]></title>
      <url>%2F2017%2F04%2F06%2Fjava-index%2F</url>
      <content type="text"><![CDATA[参考资料： 《The Java® Virtual Machine Specification(Java SE 8 Edition)》《Java 虚拟机规范(Java SE 7)》中文版本Java 虚拟机规范 《The Java® Virtual Machine Specification(Java SE 8 Edition)》《The Java Language Specification,Java SE 7 Edition》Java 语言规范 《Oracle JRockit The Definitive Guide》 oracle 出品 JRockit 虚拟机高级使用指南， 2010年7月出版 《Inside the Java 2 Virtual Machine,Second Edition》 2000年1月出版， 《Java Performance》 只有第3、4、7 章与Java虚拟机相关，是从操作系统到基于Java的上层程序性能度量和调优的全面介绍，其中设计Java虚拟机的内容具备一定的深度和可实践性。 高级语言虚拟机圈子： 高级语言虚拟机圈子：http://hllvm.group.iteye.com/ Java 体系结构传统意义上，Sun官方定义的Java 体系结构包括： Java 程序设计语言 Java 虚拟机 Class 文件格式 Java API 类库 Jdk 与 JRE 的关系 Java 的4个版本 Java Card：支持Java小程序(Applets)运行在小内存设备上。 Java ME ： 对Java API 有所精简，加入对移动设备的支持。 Java SE ： 提供完整的Java 核心 API，桌面级应用。 Java EE ： 企业开发，在Java SE API 之外，增加了大量的扩充并提供了相关的部署支持。 扩展一般以javax.\作为包名， 以java. 为包名的都是Java SE API，后来历史发展，一部分扩展包也被划分为核心包了，所以部分核心包也以javax.为包名* Java 发展JDK 1.2 中细分为J2EE\J2SE\J2ME三个方向，内置了Classic VM、Hotspot VM、Exact VM(只在solaris平台上)，后两个VM 内置 JIT 编译器。添加了 strictfp 关键字与collections 集合类。 JDK 1.3 主要改进了类库，JNDI 开始作为一项平台级服务提供，使用 CORBA IIOP 实现 RMI 通信协议， 改进了Java2D API, 新增JavaSound类库。 JDK 1.4 Java走向成熟的标志！新特性：正则表达式、异常链、NIO、日志类、XML解析器、XSLT转换器等。 JDK 1.5 主要改进易用性，出现的新特性主要有：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环(foreach)。在虚拟机和API上，改进了Java的内存模型、提供了java.util.concurrent并发包。 JDK 1.6 转为 Java EE、 Java SE、 Java ME 的命名方式。提供动态语言支持（内置 mozilla JavaScript rhino引擎），提供编译API 和 微型HTTP服务器API等，同时对Java虚拟机内部改动：锁与同步、垃圾收集、类加载等方面。 JDK 1.7 新的G1收集器、加强对非Java语言的调用支持，升级类加载架构等。 JDK 1.8 特性：接口添加非抽象的方法实现(default 关键字)、Lambda表达式、函数式接口、方法构造函数引用、全新的日期API、多重注解。 Java 虚拟机发展Sun Classic VM/Exact VMClassic VM刚开始不提供JIT编译器，后来通过外挂的方式提供JIT编译器。JIT编译器会完全接管虚拟机的执行系统，解释器和JIT编译器不能同时工作。VM的虚拟机，它的执行系统已经具备现代高性能虚拟机的雏形：如两级即时编译器、编译器与解释器混合工作模式等。Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。 Hotspot VM优点：热点代码探测技术、JIT编译器、混合的运行时系统。后与JRockit vm 整合，添加JRockit的垃圾回收器、MissionControl服务。 Sun Mobile-Embedded VM\Meta-Circular VM移动设备上的 VM BEA JRockit\IBM J9 VMAzul VM\BEA Liquid VMAzul VM 专有系统上的VM，Azul systems 公司的 Zing JVM 提供接近Vega系统的特性。 Liquid VM 不需要操作系统的支持，越过操作系统直接控制硬件。 Apache Harmony\ Dalvik VM这两个都不算正规的VM Microsoft JVM微软的JVM 为了在IE 中支持Java小程序，后来抛弃不开发了。 混合语言Clojure、JRuby、Java、Groovy 多核并行JDK 1.7 加入的包java.util.concurrent.forkjoin 扩充了并发框架java.util.concurrent。fork/join 模式！ Sumatra 项目提供java接入cpu运算能力的工具。 64位虚拟机64位虚拟机性能比32位差？感觉很奇怪。64位的优点是能够提供更大的内存空间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[珠海宽德科技面试]]></title>
      <url>%2F2017%2F04%2F05%2Finterview%2Finterview-wizardquant-1%2F</url>
      <content type="text"><![CDATA[面试过程 介绍个人的项目经验 java、操作系统、python等基础知识点 项目经验简单和面试官介绍了下个人的项目经验，说的并不好，还是需要练习，各种项目指标细节我都没有谈到，只是简单说了下个人负责的功能。 Java Java 反射能够实现什么？ Java gc 如何确定对象需要被清除？ Java gc 为什么要分成老年代和新生代？ volatile 修饰符作用？ synchronized修饰符作用？ Java 无锁类型？ 这个没听清 操作系统 cpu 调度方式 父子进程fork后共享什么？ 进程和线程的区别？ 进程间通信有几种？ 子进程 fork 后进程空间，CopyOnWrite！！！ 中断分类，时钟中断 python set 是怎么实现的？ 如何求 set 的交集？ 数据库 如何实现读写分离？ 数据库实现同步方式。 问的都挺基础，自己没搞清楚。。。应该也跪了！回家养猪，养猪~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[珠海习悦面试]]></title>
      <url>%2F2017%2F04%2F05%2Finterview%2Finterview-thinkjoy-1%2F</url>
      <content type="text"><![CDATA[记一次略感神奇的面试经历~上来先自我介绍了一下然后介绍在做的深度学习抓取物体的实验，介绍个人的深度学习方面看的论文、学习实践情况等 有点囧啊，其他的问题都没问。。。第一次想主动和面试官说说话！！！可能面试官没面试过几次？也许吧 后来也没什么消息了，好像进了人才库，什么鬼嘛，想找个实习难了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-4 布局管理【Layout management in PyQt5】]]></title>
      <url>%2F2017%2F04%2F04%2FPyQt5%2FPyQt5-4%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 布局管理是GUI 编程一个重要的方面。布局管理是如何在窗口中安排部件的方法。可以通过设置绝对位置、或使用布局类这两种基本方式管理布局。 绝对布局【Absolute positioning】在像素级别设置每个部件的位置和大小。当使用绝对布局时，需要理解以下的限制： 当改变窗口大小的时候，部件的大小和位置不能更改。 应用也许在不同平台上显示效果不一致。 改变应用的字体也许会毁掉布局。 如果决定改变布局，需要重新设计布局，非常消耗时间、乏味 下面的例子将按绝对布局放置widgets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows three labels on a windowusing absolute positioning. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QLabel, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lbl1 = QLabel('Zetcode', self) lbl1.move(15, 10) lbl2 = QLabel('tutorials', self) lbl2.move(35, 40) lbl3 = QLabel('for programmers', self) lbl3.move(55, 70) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Absolute') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 使用 move（）方法设置widgets 的位置。 本例子中的widgets都是label，通过设置（x，y） 坐标设置其位置。坐标系统的原点位于左上角。x坐标轴方向由左向右，y坐标轴由上向下。 12lbl1 = QLabel('Zetcode', self)lbl1.move(15, 10) label widget 位置是 x=15, y = 10 盒式布局 【Box layout】布局类管理布局更加灵活和实际。QHBoxLayout 和 QVBoxLayout 是使weigets 成水平、垂直排列的基类。 Imagine that we wanted to place two buttons in the right bottom corner. To create such a layout, we will use one horizontal and one vertical box. To create the necessary space, we will add a stretch factor. 12okButton = QPushButton("OK") cancelButton = QPushButton("Cancel") 创建两个按钮1234hbox = QHBoxLayout()hbox.addStretch(1)hbox.addWidget(okButton)hbox.addWidget(cancelButton) 创建水平布局并添加stretch因子和两个按钮。stretch 添加在两个按钮之前一个可伸缩空间，能够使两个按钮移动到窗口右边。 123vbox = QVBoxLayout()vbox.addStretch(1)vbox.addLayout(hbox) 创建一个垂直布局，添加stretch 和 hbox布局，stretch 会令hbox 位于窗口的底部。最后，效果如下： 栅格布局 【QGridLayout】最通用的布局类是栅格布局，按行列的方式分割空间。QGridLayout 实现了栅格布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a skeletonof a calculator using a QGridLayout.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QGridLayout, QPushButton, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout() self.setLayout(grid) names = ['Cls', 'Bck', '', 'Close', '7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', '.', '=', '+'] positions = [(i,j) for i in range(5) for j in range(4)] for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) self.move(300, 150) self.setWindowTitle('Calculator') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 声明在grid中的位置： 123456for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) 效果如： Review example在grid 布局中，widgets 可以横垮多个行列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a bitmore complicated window layout usingthe QGridLayout manager. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): title = QLabel('Title') author = QLabel('Author') review = QLabel('Review') titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QTextEdit() grid = QGridLayout() grid.setSpacing(10) grid.addWidget(title, 1, 0) grid.addWidget(titleEdit, 1, 1) grid.addWidget(author, 2, 0) grid.addWidget(authorEdit, 2, 1) grid.addWidget(review, 3, 0) grid.addWidget(reviewEdit, 3, 1, 5, 1) self.setLayout(grid) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('Review') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 12grid = QGridLayout()grid.setSpacing(10) 创建grid layout 并设置widgets 间距离spacing grid.addWidget(reviewEdit, 3, 1, 5, 1) 设置 reviewEdit 位于第三行，第一列，占5行，1列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-3 PyQt5 的菜单、工具栏【Menus and toolbars in PyQt5】]]></title>
      <url>%2F2017%2F03%2F24%2FPyQt5%2FPyQt5-3%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 这一部分将会介绍如何创建菜单、工具栏。 菜单是一组命令的集合，以菜单栏的形式展现。工具栏带有应用的一些命令的按钮。 主窗口【Main Window】QMainWindow类提供了应用主窗口，能够用于创建典型的具有状态栏、工具栏和菜单栏的应用模式。 状态栏【Statusbar】状态栏是用于显示状态信息的部件(widget) 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a statusbar.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.statusBar().showMessage('Ready') self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Statusbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 状态栏在QMainWindow下创建。1self.statusBar().showMessage('Ready') 通过调用QtGui.QMainWindow的statusBar()方法获得状态栏，首次调用将创建一个状态栏，后续的调用会返回状态栏对象。showMessage() 方法在状态栏显示消息。 菜单栏 【Menubar】菜单栏是常用的GUI应用部分。它包含一组的不同的命令菜单（Mac 的菜单栏有点不同）。为了获得相似的效果，可以使用此方法menubar.setNativeMenuBar(False)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a menubar. Themenubar has one menu with an exit action.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(qApp.quit) self.statusBar() menubar = self.menuBar() menubar.setNativeMenuBar(False) fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Menubar') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上面的例子中，新建一个带有菜单的菜单栏。菜单包括一个终止应用的action。同时也新建一个状态栏。action可以通过Ctrl+Q 快捷键触发。 123exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q')exitAction.setStatusTip('Exit application') QAction 是菜单栏、工具栏上操作的抽象，可以自定义快捷键。上面的代码创建一个具有图标、“Exit”标签、与快捷键的action。第三行设置状态提示，当鼠标悬停在菜单项上时就会触发。 1exitAction.triggered.connect(qApp.quit) 当选择特定的action，触发特定的 signal，此 signal 与 QApplication widget的quit() 方法连接，会使应用退出。 123menubar = self.menuBar()fileMenu = menubar.addMenu('&amp;File')fileMenu.addAction(exitAction) menuBar() 方法创建菜单栏，上面代码中创建了一个 file 菜单，与一个 exitAction 操作。 工具栏 Toolbar应用中的所有命令成组的方式放置于菜单中。 工具栏提供了快速访问常用命令的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorialThis program creates a toolbar.The toolbar has one action, whichterminates the application, if triggered.author: Jan Bodnarwebsite: zetcode.comlast edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.triggered.connect(qApp.quit) self.toolbar = self.addToolBar('Exit') self.toolbar.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Toolbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上述例子，创建简单的工具栏（带有一个退出action）。 123exitAction = QAction(QIcon('exit24.png'), 'Exit', self)exitAction.setShortcut('Ctrl+Q')exitAction.triggered.connect(qApp.quit) 类似于上述的菜单栏，创建 action 对象（具有标签、图标、快捷键），triggered 信号连接到 exit()方法。 12self.toolbar = self.addToolBar('Exit')self.toolbar.addAction(exitAction) 创建工具栏。 集成到一起 Putting it together在本节的最后一个例子中，展示一个带有菜单栏、工具栏、状态栏和 中央widget 的应用例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) exitAction = QAction(QIcon('exit24.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(self.close) self.statusBar() menubar = self.menuBar() fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) toolbar = self.addToolBar('Exit') toolbar.addAction(exitAction) self.setGeometry(300, 300, 350, 250) self.setWindowTitle('Main window') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例子创建了经典的带有菜单栏、工具栏、状态栏的GUI应用。 12textEdit = QTextEdit()self.setCentralWidget(textEdit) 文本编辑控件，处于窗口中心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-2 第一个程序 【First programs】]]></title>
      <url>%2F2017%2F03%2F21%2FPyQt5%2FPyQt5-2%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 简单示例该例子显示一个小窗口。可以利用这个窗口完成很多事情，比如调整大小、最大化、最小化。而这需要大量的代码。已经内置了此部分代码，因为此部分代码在大多数程序中都需要使用，不需要重复编码此部分功能。PyQt5是一个高级的工具集，如果使用低级别的工具集开发编码，以下的例子很可能产生上百行代码。 1234567891011121314151617181920212223242526272829#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a simplewindow in PyQt5.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetif __name__ == '__main__': app = QApplication(sys.argv) w = QWidget() w.resize(250, 150) w.move(300, 300) w.setWindowTitle('Simple') w.show() sys.exit(app.exec_()) 上面代码展示一个小窗口 12import sysfrom PyQt5.QtWidgets import QApplication, QWidget 导入必要的模块。基本的小部件在PyQt5.QtWidgets 模块中。 1app = QApplication(sys.argv) 每个PyQt5 应用必须创建一个application 对象。sys.argv 参数是命令行参数的列表。Python 脚本可以从shell运行，通过这种方式可以控制脚本的启动方式。1w = QWidget() QWidget 部件是PyQt5中所有用户界面对象的基类。我们提供了默认的QWidget构造器，默认的构造器没有父级元素。（没有父级元素的部件称为窗口）1w.resize(250, 150) resize() 方法调整部件的大小. 宽度：250px； 高度：150px1w.move(300, 300) move()把部件移动到坐标为（300，300）处。1w.setWindowTitle('Simple') 设置窗口的标题。表示在标题栏展示。1w.show() show()在窗口上显示部件。部件首先在内存中创建，然后在屏幕上展示。1sys.exit(app.exec_()) 最后，进入应用主循环。事件处理从此调用开始。主循环从窗口系统接收事件、把分发事件到应用部件。当exit()调用或主部件销毁即引发主循环结束。sys.exit() 方法确保干净的退出，通知系统应用如何退出。 exec_() 方法包含一个下划线。 因为exec 是Python的关键字,因此使用exec_()代替。 应用程序图标 (application icon)应用图标是标题栏左上角显示的小图像，接下来的例子会教大家如何在PyQt5中实现应用图标，顺带介绍一些新的方法调用。 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows an iconin the titlebar of the window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetfrom PyQt5.QtGui import QIconclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 300, 220) self.setWindowTitle('Icon') self.setWindowIcon(QIcon('./image/web.png')) self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 提示 （Tooltip）对每一个部件可以提供一个帮助提示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a tooltip on a window and a button.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication)from PyQt5.QtGui import QFont class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): QToolTip.setFont(QFont('SansSerif', 10)) self.setToolTip('This is a &lt;b&gt;QWidget&lt;/b&gt; widget') btn = QPushButton('Button', self) btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') btn.resize(btn.sizeHint()) btn.move(50, 50) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Tooltips') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 本例中展现了如何为PyQt5 部件添加 tooltip。 1QToolTip.setFont(QFont('SansSerif', 10)) 此静态方法设置tooltop渲染的字体，这里使用了SansSerif字体,大小为10px。 1self.setToolTip(&apos;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&apos;) 使用setToolTip 设置 tooltip， 可以使用富文本格式。 12btn = QPushButton('Button', self)btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') 添加push button 部件，及为push button 设置tooltip。 12btn.resize(btn.sizeHint())btn.move(50, 50) button 在窗口中重新设置大小、移动位置。 sizeHint() 使得 button 能够获得一个推荐适当的大小。 Figure: Tooltip 关闭窗口关闭窗口最明显的方式就是“点击标题栏的x标记”。在下一个例子中，我们会展示如何通过编码的方式关闭窗口。我们会开始接触到signals(信号)和 slots(槽) 。 下面是QPushButton 部件的构造函数。1QPushButton(string text, QWidget parent = None) text 参数是button上显示的文本。parent 是放置 button 的部件(widget). 在本例中他就是一个QWidget。应用中的Widegets形成层次结构，大多数Widget都有其parent，没有parent的Widgets是顶层的窗口. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a quitbutton. When we press the button,the application terminates. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QPushButton, QApplicationfrom PyQt5.QtCore import QCoreApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): qbtn = QPushButton('Quit', self) qbtn.clicked.connect(QCoreApplication.instance().quit) qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Quit button') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例中，创建了一个退出按钮，点击按钮，程序即退出。1from PyQt5.QtCore import QCoreApplication 需要导入QtCore中的包 1qbtn = QPushButton('Quit', self) 我们新建了一个QPushButton的实例。构造函数的第一个参数是按钮的标签，第二个参数是widget的parent。此处的parent是继承的QWidget对象。 1qbtn.clicked.connect(QCoreApplication.instance().quit) PyQt5的事件处理系统构建与 signal 和 slot 机制之上。如果我们点击按钮，信号就会被激发。slot 可以是一个Qt槽、或者python 可调用对象。QCoreApplication 包括一个主事件循环（处理和分发事件循环）；instance()方法返回一个当前实例。注意：QCoreApplication 是与 QApplication 一起创建的。clicked信号连接到quit()方法【quit方法用于结束应用】。接收者（push button）和发送者（application object）中负责互相通讯。 消息框（Message Box）默认情况下，如果点击标题栏的关闭按钮（x），QWidget 将被关闭。在某些情况下需要对这种行为进行修改，比如：编辑器中有仍未保存的被修改的文件，应该在关闭时出现一个确认行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program shows a confirmation message box when we click on the closebutton of the application window. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Message box') self.show() def closeEvent(self, event): reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 当关闭此QWidget时，触发QCloseEvent事件，通过重写closeEvent()事件控制方法修改默认的关闭行为。123reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) 显示一个带有两个按钮的消息框（yes 和 no）。第一个 字符串 参数在标题栏显示。第二个 字符串 参数是在对话框中显示的，第三个参数定义了出现在消息框中的按钮。最后一个参数定义默认的按钮。返回值传递给reply。 1234if reply == QtGui.QMessageBox.Yes: event.accept()else: event.ignore() 此处根据返回值判断是否关闭窗口，点击“yes”即接受事件，关闭widget和终止应用。否者，忽视此事件。 屏幕居中（centering window on the screen）此例展示如何在屏幕居中显示应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program centers a window on the screen. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) self.center() self.setWindowTitle('Center') self.show() def center(self): qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() qr.moveCenter(cp) self.move(qr.topLeft()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QtGui.QDesktopWidget 类提供了用户桌面的相关信息，包括桌面尺寸。 1self.center() 此方法实现了将程序移到屏幕的中央。 1qr = self.frameGeometry() 获得主窗口的方框描述，包括了任何窗口框。 1cp = QDesktopWidget().availableGeometry().center() 获得屏幕geometry，通过geometry获得屏幕的中心位置。 1qr.moveCenter(cp) 将窗口的中心位置移动到屏幕的中心，窗口的大小并不发生变化 1self.move(qr.topLeft()) 移动窗口的左上角到移动到qr的左上角，这样窗口就在屏幕的正中央了。 这部分介绍了一些基本PyQt5 知识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-1 简介 【Introduction】]]></title>
      <url>%2F2017%2F03%2F18%2FPyQt5%2FPyQt5-1%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 关于 PyQt5 【About PyQt5】PyQt5 是Digia的Qt5应用框架的python绑定实现。在 Python2 和 Python3 环境下皆可用。本教程使用 Python3。Qt 是最强大的GUI库之一。PyQt5的官方网站是www.riverbankcomputing.co.uk/news。PyQt5 由 Riverbank Computing 开发并维护。 PyQt5 以一系列Python模块的形式实现，其具有620个以上的类和6000个函数、方法。它是个跨平台的工具集（Unix、windows、mac）。PyQt5使用2个发行协议（GPL 和 商业协议） PyQt5 划分为以下几个模块： QtCoreQtCore 模块包含了核心的非GUI功能。此模块用于处理 time、files与 directories、不同的数据类型、流、URLs、mine types、线程或进程。 QtGuiQtGui 包括集成的窗口系统、事件处理、2D Graphics、basic imaging、字体、文本。 QtWidgetsQtWidgets 提供基本UI元素（以类的方式）创建典型的桌面用户界面。 QtMultimediaQtMultimedia 包括处理多媒体内容的类和访问camera、radio功能的Api QtBluetookQtBluetooh 模块包括蓝牙的扫描、链接及交互功能 QtNetworkQtNetwork 模块用于网络编程。此模块实现了TCP/IP 和 UDP 客户端、服务器使得网络编程更加简单和可移植。 QtPositioningQtPositioning 用于从多种源头获取位置信息；比如 satellite、Wifi、或文本文件。 EnginioEnginio 提供了client-side library用于访问Qt Cloud Services Managed Application Runtime。 QtWebSocketsQtWebSockets 实现了 WebSocket 协议 QtWebkitQtWebkit 提供了一个基于WebKit2库的web浏览器实现。 QtWebkitWidgetsQtWebkitWidgets 提供了在QtWidgets应用中使用的基于Webkit1的浏览器。 QtXmlQtXml 用于处理xml文件，此模块提供了基于SAX和DOM 的api QtSvgQtSvg 模块用于显示SVG文件。Scalable Vector Graphics (SVG) 是一种用XML描述二维图像、图形应用的语言。 QtSqlQtSQL 用于数据库相关工作。 QtTestQtTest 用于 PyQt5 应用的单元测试。 PyQt4 和 PyQt5 的区别 【Difference between PyQt4 and PyQt5】PyQt5 并不向后兼容（向下兼容）PyQt4; PyQt5 中发生了几大显著变化。然而把旧版本的代码重构到新的库中并不十分困难。PyQt5与PyQt4 的区别具体为： Python 的模块重新组织。一些模块被丢弃了（比如QtScript）,有些被划分到子模块中（比如QtGui、 QtWebKit）。 引入了新的模块，包括 QtBluetooth， QtPositioning、Enginio。 PyQt5 只支持新式的“信号-槽”事件处理机制。SIGNAL() 和 SLOT() 调用不再被支持。 PyQt5 不再支持任何在Qt v5.0被声明为deprecated（不提倡使用）或obsolete（废弃）的 Qt API。 PythonPython 是一种高级、动态、通用、跨平台、解释性、面向对象的编程语言。 Python的设计目的是突出程序员的效率和代码可读性。Python最开始由 Guido van Rossum 开发，于1991年首次发布。Python受ABC、Haskell、Java、Lisp、Icon、Perl启发。Python 简洁抽象，最直观的特性之一就是其代码使用缩进代替分号和花括号。Python目前有两大分支-Python2.x、Python3.x，Python3.x打破了向后兼容性，其目的是修正存在的设计错误，使得语言更加干净。Python由世界上的志愿者进行维护，它是开源的，Python是学习编程的理想入门语言。 本教程使用Python3.x 版本。 Python支持多种编程类型。它并不规范于特定的范式。Python 支持面向对象 与过程化编程。也提供有限的函数式编程支持。 Python的官方站点是 python.org Perl、Python、 Ruby 是广泛使用的脚本语言。它们存在诸多相同点；互相竞争。 本章节是PyQt5 工具集的介绍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[First Blog]]></title>
      <url>%2F2017%2F03%2F15%2Fhello%2F</url>
      <content type="text"><![CDATA[不可避俗的来一句：hello world!很想做个人博客，静态博客工具提供了一种很廉价的创建博客方式！在pelican、hugo、hexo三者中，我最终选择了hexo 与其中的 next 主题。真的很感谢hexo 与next主题的创建者们！！！！ 原本有想法自己做一个~但是自从看到这么优秀的框架后，就打消了这个念头！！！界面很优秀、很有趣！ 配置结合github 提供的 pages 服务构建个人网站。简单记录一下配置过程： 安装 node\npm这个参考网上教程就好，注意设置环境变量 安装 hexo123456789101112# 安装 hexonpm install hexo-cli -g# 初始化博客hexo init &lt;博客位置&gt;cd &lt;博客位置&gt;# 安装相应依赖npm install# 本地搜索插件npm install hexo-generator-searchdb --save# 启动ｈｅｘｏ服务器hexo server 安装 next 主题12$ cd &lt;博客位置&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 注意将 next中的.git 目录删掉，因为之后要用自己的git仓库托管。 hexo 博客设置hexo 博客配置文件位于 &lt;博客位置&gt;/_config.yml 修改以下项目，根据自己需要修改：12345678title: &lt;博客标题&gt;subtitle: &lt;博客子标题&gt;description: &lt;博客描述&gt;author: &lt;你的名字&gt;language: zh-Hansurl: &lt;个人博客url&gt; 启用next主题1theme: next 配置git-pages位置123456# Deployment## Docs: 设置部署位置，此处使用git-pages服务deploy: type: git repo: git@github.com:dandan32/dandan32.github.io.git branch: master 配置本地搜索123456# 搜索设置search: path: search.xml field: post format: html limit: 10000 主题博客配置参考官方教程]]></content>
    </entry>

    
  
  
</search>
