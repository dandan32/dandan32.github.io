<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[今日头条爬虫实习生面试]]></title>
      <url>%2F2017%2F04%2F26%2Finterview_toutiao%2F</url>
      <content type="text"><![CDATA[面试官先问了我的爬虫项目经验，对于爬虫的各种细节都问到了，还有截取非http的爬虫？应该比较少吧，第一次听说。感觉爬虫方面还是回答的比较好的。 后来问了我两个算法方面的问题： A、B两个有序（升序）数组，寻找去其中第k大的元素。 我的回答是“使用两个指示器指示数组末尾位置，比较相对应的位置元素大小，大的就往前移动，移动k次后，返回移动对应的元素”，然后面试官问时间复杂度，和空间复杂度，当时没反应过来，时间复杂度就是O(k)呀，空间复杂度，由于只需要额外3个元素存储指示信心，所以空间复杂度是O(3)。 A、B两人轮流下棋，棋盘是圆的，轮留下，棋盘没有格子，当棋盘满了，不能放棋子的人就输了，如何保证自己必赢。 答案很巧妙，当时没有想出来，“首先需要在棋盘中心位置下一子，以后，每次都在对手下棋位置关于圆心对称的地方放置棋子”，此法可保证必胜。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小米暑期软件研发工程师面试]]></title>
      <url>%2F2017%2F04%2F26%2Finterview_mi%2F</url>
      <content type="text"><![CDATA[简记一下小米的面试，一开始是个人介绍和项目介绍。目前发现问题是个人的介绍还是很简单，没有很好突出自己的优点，在项目中的一些难点，复杂点也没有向面试官介绍清楚，小米的面试官给人一种很亲切的感觉。后来就开始线上笔试，笔试很特殊，是以共享文档的方式考察个人的算法功底，面试官写一行，我回答一行。 题目大体是： 用链表表示一个数：123 表示为 1 -&gt; 2 -&gt; 3，给出两个数，求其和，结果也用链表形式返回。 比较简单的一道题目，将链表反转，进行相加操作后，返回结果即可， 值得我留意的是： 这里链表反转用3个指针就可以使得原链表反转，可以不用构建一个新链表 set类可以O(1)的复杂度进行查找 位图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习 绪论]]></title>
      <url>%2F2017%2F04%2F20%2FMachineLearning_1%2F</url>
      <content type="text"><![CDATA[《机器学习-周志华》笔记 第一章 什么是机器学习？人类能够从日常生活中观察事物的规律，总结而成经验，继而以经验辅助判断指导实践活动。获得经验的过程就是学习的过程。那么计算机能够产生对事物更深层次的理解吗？机器学习主要研究的内容是从 数据 中产生 模型 的算法，即学习算法（learning algorithm）。学习算法能够根据提供的经验数据产生模型，在面对新情况时以模型作为依据提供相应判断或产出。 【Machine Learning,Tom Mitchell 1997】给出了更形式化的定义：假设用P来评估计算机程序在任务类T上的性能，若一个程序通过利用经验E在T中任务上获得性能改善，则我们就说关于T和P，该程序对E进行了学习 基本术语 模型： “模型” 泛指从数据中学习得到的结果。 数据集： 一批数据的集合，数据集由样本构成。 示例(instance)、样本(sample)： 数据集合中的每一条记录称为示例(样本)，示例构成数据集。样本属性的个数d称为样本的” 维度 “(dimensionality), 具备了 标记(label) 的样本称为 样例(example) 。 属性(特征) [属性空间] [样本空间] [输入空间]： 反映事物或对象在某方面的表现或性质的事项，属性张成的空间称为” 属性空间 “、” 样本空间 “、” 输入空间 “。 学习(learning)、训练(training) [训练集]： 从数据中学的模型的过程称为” 学习 “、” 训练 “。训练过程使用的数据称为” 训练数据 “，其中每个样本称为” 训练样本 “，训练样本组成的集合称为” 训练集 “。 测试(testing) [测试集]： 学习模型后，对模型进行评估从而用一组新数据进行预测的过程称为” 测试 “，而这组新的数据称为 “ 测试集 “，被预测的样本称为 “ 测试样本 “ 假设(hypothesis): 学习得到的模型对应了关于数据的某种潜在的规律，因此也称 “假设”。模型有时也称 “学习器”。 分类、 回归： 若预测的目标是离散的，则学习任务称为”分类”；若目标是连续值，则学习任务称为”回归”。只涉及两个类别的称为”二分类”，通常称一类为” 正类 “、另一类为” 反类 “；涉及多个类别的分类称为 “ 多分类 “ 聚类： 将数据集上的样本分类若干组，每组称为” 簇 “。聚类过程中使用的数据样本通常不含有标记信息。 监督学习、无监督学习、半监督学习 泛化： 指学习得到的模型适用于新样本的能力。 假设空间归纳与演绎，是科学推理的两大基本手段。归纳指的是特殊到一般的泛化；演绎指的是一般到特殊的泛化。机器学习是从样例中学习，所以也称” 归纳学习 “。机械的记住” 训练样本 “的学习方式称为” 机械学习 “,只是简单的记住训练样本对于未遇见过的样本来预测效果会很差。考虑这样一个例子：选西瓜，可以根据根蒂、敲声、色泽综合判断西瓜是否是好瓜的情况。用布尔表达式为： $$ 好瓜\leftrightarrow(色泽=?)\vee(根蒂=?)\vee(敲声=?) $$ 更一般的情况应考虑析合范式: $$(A \vee B) \wedge (C \vee D)$$ 我们把学习过程看作是在所有假设组成的空间中进行搜索的过程，搜索目标是寻找与“训练集”匹配的假设。在西瓜例子中可以知道，色泽可以取“青绿”、“乌黑“ 2种取值，或色泽对好瓜根本没有影响（即其实是3种取值）；根蒂可以取“蜷缩”、“稍蜷”、“硬挺” 3种取值，也可能根蒂对好瓜没有影响（即其实是4种取值）；敲声可取“浊响”、“清脆” 2种取值，也可能敲声对好瓜也无影响（也即其实是3种取值）；也可能根本不存在好瓜这一食物。所如果假设色泽、根蒂、敲声的各有3、2、2种取值，计算时每个取值需要附加上 无影响选择以可以知道面试的假设空间大小为: $$ 4 \times 3 \times 3 + 1 = 37$$ 基于训练集进行训练得到与训练集一致的假设（能够在训练集上作出正确判断、预测），就是学习的结果。在现实问题中可能面临一个很大的假设空间，但是学习过程是基于样本集进行的，因此很可能出现多个假设与训练集一只，即存在一个与训练集一致的“假设集合”，称之为“ 版本空间 ”。 训练集合： 编号 色泽 根蒂 敲声 好瓜 1 青绿 蜷缩 浊响 是 2 乌黑 蜷缩 浊响 是 3 青绿 硬挺 清脆 否 4 乌黑 稍蜷 沉闷 否 西瓜问题的版本空间，现在具有3个假设与训练集一致；对于训练集而言，无法判定哪一个假设更加好。然而对于具体的学习算法而言，必须给出一个模型。这时算法本身的“ 偏好 ”就会其到关键作用。如果算法喜欢尽可能“特殊”的模型，则它会选择 $$ 好瓜\leftrightarrow(色泽=\star)\vee(根蒂=蜷缩)\vee(敲声=浊响) $$ 但如果算法喜欢更加一般的模型，并且由于某种原因它更加愿意“相信”根蒂，则它会选择：$$ 好瓜\leftrightarrow(色泽=\star)\vee(根蒂=蜷缩)\vee(敲声=\star) $$ 机器学习算法在学习过程中对某种类型假设的偏好，称为“归纳偏好”，或简称 “ 偏好 ”， 任何一个有效的机器学习算法必有其归纳偏好，否则它将被假设空间中看似在训练集上“等效”的算法所迷惑，而无法产生确定的学习结果。可以想像，对于一个新瓜，我们的学习算法随机挑选版本空间中的一个假设时而告诉它是好瓜，时而告诉它是坏瓜，这样的学习显然没有任何意义。关于“ 归纳偏好 ”使用回归学习图更加直观，对于下图的点集，要学的一个与训练集一致的模型，相当于找到一条穿过所有样本点的曲线。显然，对有限个样本点组成的训练集，存在很多条与其一致。我们的学习算法必须有某种偏好，才能产出他认为“正确”的模型。归纳偏好可以看作是在假设空间中对假设进行选择的启发式，或“价值观”。 “ 奥卡姆剃刀原则 ”是常用的一种方法，奥卡姆剃刀原则表示“ 若有多个假设与观察一致，则选择最简单的那个 ”。 很多时候，算法A在某些问题上表现比算法B更加好，而算法B在某些问题上表现比算法A更好。证明过程 P8 机器学习发展历程符号主义，逻辑推理1963 年 “逻辑理论家”程序 证明了罗素和怀特海的 《数学原理》 中的52条定理 知识工程20世纪 70年代中期，人工智能进入“知识期”，专家系统。 连接主义20世纪 50年代 罗森布莱特 的 感知机。 神经网络、深度学习等。 统计学习20世界90年代中期，统计学习占据主导地位。 行为主义来源于控制论，又称进化主义，其原理为控制论及感知-动作型控制系统。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5_11 俄罗斯方块]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5_11%2F</url>
      <content type="text"><![CDATA[俄罗斯方块俄罗斯方块是最流行的电脑游戏之一，1985年俄罗斯开发者 Alexey Pajitnov 开发出最初的原型。 六种基本形状 S 形块 Z 形块 T 形块 L 形块 镜像L形块 线形块每种形状都有四个方块组成，形状从上往下掉落，可以通过旋转改变形状的姿态，尽可能适应填满一行。如果填满一行，则该行删除获得相应分数。累积到顶部则游戏结束。 开发通过绘图API绘制形状，电脑游戏背后都有一些数学模型，俄罗斯方块也是如此。一些思路 使用QBasicTimer() 创建游戏循环 绘制形状 形状以方块移动，而不是像素。 模型化背板为数字的列表。 代码由四个类组成：Tetris, Board, Tetrominoe 和 Shape。Tetris 类构建游戏，Board负责游戏逻辑，Tetrominoe表示所有的方块名字，Shape类表示方块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This is a Tetris game clone.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sys, randomfrom PyQt5.QtWidgets import QMainWindow, QFrame, QDesktopWidget, QApplicationfrom PyQt5.QtCore import Qt, QBasicTimer, pyqtSignalfrom PyQt5.QtGui import QPainter, QColor class Tetris(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.tboard = Board(self) self.setCentralWidget(self.tboard) self.statusbar = self.statusBar() self.tboard.msg2Statusbar[str].connect(self.statusbar.showMessage) self.tboard.start() self.resize(180, 380) self.center() self.setWindowTitle('Tetris') self.show() def center(self): screen = QDesktopWidget().screenGeometry() size = self.geometry() self.move((screen.width()-size.width())/2, (screen.height()-size.height())/2) class Board(QFrame): msg2Statusbar = pyqtSignal(str) BoardWidth = 10 BoardHeight = 22 Speed = 300 def __init__(self, parent): super().__init__(parent) self.initBoard() def initBoard(self): self.timer = QBasicTimer() self.isWaitingAfterLine = False self.curX = 0 self.curY = 0 self.numLinesRemoved = 0 self.board = [] self.setFocusPolicy(Qt.StrongFocus) self.isStarted = False self.isPaused = False self.clearBoard() def shapeAt(self, x, y): return self.board[(y * Board.BoardWidth) + x] def setShapeAt(self, x, y, shape): self.board[(y * Board.BoardWidth) + x] = shape def squareWidth(self): return self.contentsRect().width() // Board.BoardWidth def squareHeight(self): return self.contentsRect().height() // Board.BoardHeight def start(self): if self.isPaused: return self.isStarted = True self.isWaitingAfterLine = False self.numLinesRemoved = 0 self.clearBoard() self.msg2Statusbar.emit(str(self.numLinesRemoved)) self.newPiece() self.timer.start(Board.Speed, self) def pause(self): if not self.isStarted: return self.isPaused = not self.isPaused if self.isPaused: self.timer.stop() self.msg2Statusbar.emit("paused") else: self.timer.start(Board.Speed, self) self.msg2Statusbar.emit(str(self.numLinesRemoved)) self.update() def paintEvent(self, event): painter = QPainter(self) rect = self.contentsRect() boardTop = rect.bottom() - Board.BoardHeight * self.squareHeight() for i in range(Board.BoardHeight): for j in range(Board.BoardWidth): shape = self.shapeAt(j, Board.BoardHeight - i - 1) if shape != Tetrominoe.NoShape: self.drawSquare(painter, rect.left() + j * self.squareWidth(), boardTop + i * self.squareHeight(), shape) if self.curPiece.shape() != Tetrominoe.NoShape: for i in range(4): x = self.curX + self.curPiece.x(i) y = self.curY - self.curPiece.y(i) self.drawSquare(painter, rect.left() + x * self.squareWidth(), boardTop + (Board.BoardHeight - y - 1) * self.squareHeight(), self.curPiece.shape()) def keyPressEvent(self, event): if not self.isStarted or self.curPiece.shape() == Tetrominoe.NoShape: super(Board, self).keyPressEvent(event) return key = event.key() if key == Qt.Key_P: self.pause() return if self.isPaused: return elif key == Qt.Key_Left: self.tryMove(self.curPiece, self.curX - 1, self.curY) elif key == Qt.Key_Right: self.tryMove(self.curPiece, self.curX + 1, self.curY) elif key == Qt.Key_Down: self.tryMove(self.curPiece.rotateRight(), self.curX, self.curY) elif key == Qt.Key_Up: self.tryMove(self.curPiece.rotateLeft(), self.curX, self.curY) elif key == Qt.Key_Space: self.dropDown() elif key == Qt.Key_D: self.oneLineDown() else: super(Board, self).keyPressEvent(event) def timerEvent(self, event): if event.timerId() == self.timer.timerId(): if self.isWaitingAfterLine: self.isWaitingAfterLine = False self.newPiece() else: self.oneLineDown() else: super(Board, self).timerEvent(event) def clearBoard(self): for i in range(Board.BoardHeight * Board.BoardWidth): self.board.append(Tetrominoe.NoShape) def dropDown(self): newY = self.curY while newY &gt; 0: if not self.tryMove(self.curPiece, self.curX, newY - 1): break newY -= 1 self.pieceDropped() def oneLineDown(self): if not self.tryMove(self.curPiece, self.curX, self.curY - 1): self.pieceDropped() def pieceDropped(self): for i in range(4): x = self.curX + self.curPiece.x(i) y = self.curY - self.curPiece.y(i) self.setShapeAt(x, y, self.curPiece.shape()) self.removeFullLines() if not self.isWaitingAfterLine: self.newPiece() def removeFullLines(self): numFullLines = 0 rowsToRemove = [] for i in range(Board.BoardHeight): n = 0 for j in range(Board.BoardWidth): if not self.shapeAt(j, i) == Tetrominoe.NoShape: n = n + 1 if n == 10: rowsToRemove.append(i) rowsToRemove.reverse() for m in rowsToRemove: for k in range(m, Board.BoardHeight): for l in range(Board.BoardWidth): self.setShapeAt(l, k, self.shapeAt(l, k + 1)) numFullLines = numFullLines + len(rowsToRemove) if numFullLines &gt; 0: self.numLinesRemoved = self.numLinesRemoved + numFullLines self.msg2Statusbar.emit(str(self.numLinesRemoved)) self.isWaitingAfterLine = True self.curPiece.setShape(Tetrominoe.NoShape) self.update() def newPiece(self): self.curPiece = Shape() self.curPiece.setRandomShape() self.curX = Board.BoardWidth // 2 + 1 self.curY = Board.BoardHeight - 1 + self.curPiece.minY() if not self.tryMove(self.curPiece, self.curX, self.curY): self.curPiece.setShape(Tetrominoe.NoShape) self.timer.stop() self.isStarted = False self.msg2Statusbar.emit("Game over") def tryMove(self, newPiece, newX, newY): for i in range(4): x = newX + newPiece.x(i) y = newY - newPiece.y(i) if x &lt; 0 or x &gt;= Board.BoardWidth or y &lt; 0 or y &gt;= Board.BoardHeight: return False if self.shapeAt(x, y) != Tetrominoe.NoShape: return False self.curPiece = newPiece self.curX = newX self.curY = newY self.update() return True def drawSquare(self, painter, x, y, shape): colorTable = [0x000000, 0xCC6666, 0x66CC66, 0x6666CC, 0xCCCC66, 0xCC66CC, 0x66CCCC, 0xDAAA00] color = QColor(colorTable[shape]) painter.fillRect(x + 1, y + 1, self.squareWidth() - 2, self.squareHeight() - 2, color) painter.setPen(color.lighter()) painter.drawLine(x, y + self.squareHeight() - 1, x, y) painter.drawLine(x, y, x + self.squareWidth() - 1, y) painter.setPen(color.darker()) painter.drawLine(x + 1, y + self.squareHeight() - 1, x + self.squareWidth() - 1, y + self.squareHeight() - 1) painter.drawLine(x + self.squareWidth() - 1, y + self.squareHeight() - 1, x + self.squareWidth() - 1, y + 1)class Tetrominoe(object): NoShape = 0 ZShape = 1 SShape = 2 LineShape = 3 TShape = 4 SquareShape = 5 LShape = 6 MirroredLShape = 7class Shape(object): coordsTable = ( ((0, 0), (0, 0), (0, 0), (0, 0)), ((0, -1), (0, 0), (-1, 0), (-1, 1)), ((0, -1), (0, 0), (1, 0), (1, 1)), ((0, -1), (0, 0), (0, 1), (0, 2)), ((-1, 0), (0, 0), (1, 0), (0, 1)), ((0, 0), (1, 0), (0, 1), (1, 1)), ((-1, -1), (0, -1), (0, 0), (0, 1)), ((1, -1), (0, -1), (0, 0), (0, 1)) ) def __init__(self): self.coords = [[0,0] for i in range(4)] self.pieceShape = Tetrominoe.NoShape self.setShape(Tetrominoe.NoShape) def shape(self): return self.pieceShape def setShape(self, shape): table = Shape.coordsTable[shape] for i in range(4): for j in range(2): self.coords[i][j] = table[i][j] self.pieceShape = shape def setRandomShape(self): self.setShape(random.randint(1, 7)) def x(self, index): return self.coords[index][0] def y(self, index): return self.coords[index][1] def setX(self, index, x): self.coords[index][0] = x def setY(self, index, y): self.coords[index][1] = y def minX(self): m = self.coords[0][0] for i in range(4): m = min(m, self.coords[i][0]) return m def maxX(self): m = self.coords[0][0] for i in range(4): m = max(m, self.coords[i][0]) return m def minY(self): m = self.coords[0][1] for i in range(4): m = min(m, self.coords[i][1]) return m def maxY(self): m = self.coords[0][1] for i in range(4): m = max(m, self.coords[i][1]) return m def rotateLeft(self): if self.pieceShape == Tetrominoe.SquareShape: return self result = Shape() result.pieceShape = self.pieceShape for i in range(4): result.setX(i, self.y(i)) result.setY(i, -self.x(i)) return result def rotateRight(self): if self.pieceShape == Tetrominoe.SquareShape: return self result = Shape() result.pieceShape = self.pieceShape for i in range(4): result.setX(i, -self.y(i)) result.setY(i, self.x(i)) return resultif __name__ == '__main__': app = QApplication([]) tetris = Tetris() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5_10 自定义部件【Custom widgets in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5_10%2F</url>
      <content type="text"><![CDATA[PyQt5 有一系列空间，然而开发者可能有某些特殊的需要。通常只提供最基本的部件，比如：按钮、文本、滚动条等。如果需要更特殊的部件，可以自行创建。通过绘图工具自定义部件，两种可能的方法，开发者可以定义、增强部件 或者自己创建一个部件。 Burning widget123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a custom widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QSlider, QApplication, QHBoxLayout, QVBoxLayout)from PyQt5.QtCore import QObject, Qt, pyqtSignalfrom PyQt5.QtGui import QPainter, QFont, QColor, QPenclass Communicate(QObject): updateBW = pyqtSignal(int)class BurningWidget(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setMinimumSize(1, 30) self.value = 75 self.num = [75, 150, 225, 300, 375, 450, 525, 600, 675] def setValue(self, value): self.value = value def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawWidget(qp) qp.end() def drawWidget(self, qp): font = QFont('Serif', 7, QFont.Light) qp.setFont(font) size = self.size() w = size.width() h = size.height() step = int(round(w / 10.0)) till = int(((w / 750.0) * self.value)) full = int(((w / 750.0) * 700)) if self.value &gt;= 700: qp.setPen(QColor(255, 255, 255)) qp.setBrush(QColor(255, 255, 184)) qp.drawRect(0, 0, full, h) qp.setPen(QColor(255, 175, 175)) qp.setBrush(QColor(255, 175, 175)) qp.drawRect(full, 0, till-full, h) else: qp.setPen(QColor(255, 255, 255)) qp.setBrush(QColor(255, 255, 184)) qp.drawRect(0, 0, till, h) pen = QPen(QColor(20, 20, 20), 1, Qt.SolidLine) qp.setPen(pen) qp.setBrush(Qt.NoBrush) qp.drawRect(0, 0, w-1, h-1) j = 0 for i in range(step, 10*step, step): qp.drawLine(i, 0, i, 5) metrics = qp.fontMetrics() fw = metrics.width(str(self.num[j])) qp.drawText(i-fw/2, h/2, str(self.num[j])) j = j + 1 class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): sld = QSlider(Qt.Horizontal, self) sld.setFocusPolicy(Qt.NoFocus) sld.setRange(1, 750) sld.setValue(75) sld.setGeometry(30, 40, 150, 30) self.c = Communicate() self.wid = BurningWidget() self.c.updateBW[int].connect(self.wid.setValue) sld.valueChanged[int].connect(self.changeValue) hbox = QHBoxLayout() hbox.addWidget(self.wid) vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) self.setLayout(vbox) self.setGeometry(300, 300, 390, 210) self.setWindowTitle('Burning widget') self.show() def changeValue(self, value): self.c.updateBW.emit(value) self.wid.repaint() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-9 绘图 【Painting in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5_9%2F</url>
      <content type="text"><![CDATA[PyQt5 绘图系统能够渲染矢量图、图片、艺术字。绘图对于改变或增强现有部件功能很重要，使用内建的绘图api进行绘制。绘制由paintEvent()方法完成。绘制代码放置在QPainter对象的begin()方法和end()方法中。 绘制文本【Drawing text】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we draw text in Russian azbuka.author: Jan Bodnarwebsite: zetcode.com last edited: September 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QFontfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.text = u'\u041b\u0435\u0432 \u041d\u0438\u043a\u043e\u043b\u0430\\u0435\u0432\u0438\u0447 \u0422\u043e\u043b\u0441\u0442\u043e\u0439: \n\\u0410\u043d\u043d\u0430 \u041a\u0430\u0440\u0435\u043d\u0438\u043d\u0430' self.setGeometry(300, 300, 280, 170) self.setWindowTitle('Draw text') self.show() def paintEvent(self, event): qp = QPainter() qp.begin(self) self.drawText(event, qp) qp.end() def drawText(self, event, qp): qp.setPen(QColor(168, 34, 3)) qp.setFont(QFont('Decorative', 10)) qp.drawText(event.rect(), Qt.AlignCenter, self.text) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 画点 【Drawing points】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In the example, we draw randomly 1000 red points on the window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sys, randomfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QPenfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 280, 170) self.setWindowTitle('Points') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawPoints(qp) qp.end() def drawPoints(self, qp): qp.setPen(Qt.red) size = self.size() for i in range(1000): x = random.randint(1, size.width()-1) y = random.randint(1, size.height()-1) qp.drawPoint(x, y) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 颜色 【colours】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example draws three rectangles in three#different colours. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QBrushclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 350, 100) self.setWindowTitle('Colours') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawRectangles(qp) qp.end() def drawRectangles(self, qp): col = QColor(0, 0, 0) col.setNamedColor('#d4d4d4') qp.setPen(col) qp.setBrush(QColor(200, 0, 0)) qp.drawRect(10, 15, 90, 60) qp.setBrush(QColor(255, 80, 0, 160)) qp.drawRect(130, 15, 90, 60) qp.setBrush(QColor(25, 0, 90, 200)) qp.drawRect(250, 15, 90, 60) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QPenQPen 是基本的图形对象，可以用户画线、曲线、举行的轮廓、阴影、几何图形和其他形状。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example we draw 6 lines usingdifferent pen styles. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QColor, QPenfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 280, 270) self.setWindowTitle('Pen styles') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawLines(qp) qp.end() def drawLines(self, qp): pen = QPen(Qt.black, 2, Qt.SolidLine) qp.setPen(pen) qp.drawLine(20, 40, 250, 40) pen.setStyle(Qt.DashLine) qp.setPen(pen) qp.drawLine(20, 80, 250, 80) pen.setStyle(Qt.DashDotLine) qp.setPen(pen) qp.drawLine(20, 120, 250, 120) pen.setStyle(Qt.DotLine) qp.setPen(pen) qp.drawLine(20, 160, 250, 160) pen.setStyle(Qt.DashDotDotLine) qp.setPen(pen) qp.drawLine(20, 200, 250, 200) pen.setStyle(Qt.CustomDashLine) pen.setDashPattern([1, 4, 5, 4]) qp.setPen(pen) qp.drawLine(20, 240, 250, 240) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QBrushQBrush 是基本的图形对象，用于图形的背景绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example draws 9 rectangles in differentbrush styles.author: Jan Bodnarwebsite: zetcode.com last edited: July 2016"""import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtGui import QPainter, QBrushfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 355, 280) self.setWindowTitle('Brushes') self.show() def paintEvent(self, e): qp = QPainter() qp.begin(self) self.drawBrushes(qp) qp.end() def drawBrushes(self, qp): brush = QBrush(Qt.SolidPattern) qp.setBrush(brush) qp.drawRect(10, 15, 90, 60) brush.setStyle(Qt.Dense1Pattern) qp.setBrush(brush) qp.drawRect(130, 15, 90, 60) brush.setStyle(Qt.Dense2Pattern) qp.setBrush(brush) qp.drawRect(250, 15, 90, 60) brush.setStyle(Qt.DiagCrossPattern) qp.setBrush(brush) qp.drawRect(10, 105, 90, 60) brush.setStyle(Qt.Dense5Pattern) qp.setBrush(brush) qp.drawRect(130, 105, 90, 60) brush.setStyle(Qt.Dense6Pattern) qp.setBrush(brush) qp.drawRect(250, 105, 90, 60) brush.setStyle(Qt.HorPattern) qp.setBrush(brush) qp.drawRect(10, 195, 90, 60) brush.setStyle(Qt.VerPattern) qp.setBrush(brush) qp.drawRect(130, 195, 90, 60) brush.setStyle(Qt.BDiagPattern) qp.setBrush(brush) qp.drawRect(250, 195, 90, 60) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-8 小部件II 【widgets II】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5_8%2F</url>
      <content type="text"><![CDATA[widgets 用法例子，不含解释。 QPixmap在屏幕上显示图片。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we dispay an imageon the window. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QHBoxLayout, QLabel, QApplication)from PyQt5.QtGui import QPixmapclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) pixmap = QPixmap("redrock.png") lbl = QLabel(self) lbl.setPixmap(pixmap) hbox.addWidget(lbl) self.setLayout(hbox) self.move(300, 200) self.setWindowTitle('Red Rock') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QLineEdit单行编辑框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows text which is entered in a QLineEditin a QLabel widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel(self) qle = QLineEdit(self) qle.move(60, 100) self.lbl.move(60, 40) qle.textChanged[str].connect(self.onChanged) self.setGeometry(300, 300, 280, 170) self.setWindowTitle('QLineEdit') self.show() def onChanged(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QSplitter将区域分割，切分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example showshow to use QSplitter widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QHBoxLayout, QFrame, QSplitter, QStyleFactory, QApplication)from PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): hbox = QHBoxLayout(self) topleft = QFrame(self) topleft.setFrameShape(QFrame.StyledPanel) topright = QFrame(self) topright.setFrameShape(QFrame.StyledPanel) bottom = QFrame(self) bottom.setFrameShape(QFrame.StyledPanel) splitter1 = QSplitter(Qt.Horizontal) splitter1.addWidget(topleft) splitter1.addWidget(topright) splitter2 = QSplitter(Qt.Vertical) splitter2.addWidget(splitter1) splitter2.addWidget(bottom) hbox.addWidget(splitter2) self.setLayout(hbox) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('QSplitter') self.show() def onChanged(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QComboBox下拉列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows how to use a QComboBox widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QComboBox, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.lbl = QLabel("Ubuntu", self) combo = QComboBox(self) combo.addItem("Ubuntu") combo.addItem("Mandriva") combo.addItem("Fedora") combo.addItem("Arch") combo.addItem("Gentoo") combo.move(50, 50) self.lbl.move(50, 150) combo.activated[str].connect(self.onActivated) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('QComboBox') self.show() def onActivated(self, text): self.lbl.setText(text) self.lbl.adjustSize() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-7 小部件 【widgets】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5_7%2F</url>
      <content type="text"><![CDATA[小部件 是应用的基础构建块。PyQt5 具备一系列不同的小部件，包括：按钮、多选按钮、滚动条、列表。此教程中，将探讨几个常用的部件，QCheckBox、ToggleButton、QSlider、QProgressBar、QCalendarWidget。 widgets 用法例子，不含解释 QCheckBox多选按钮，具备开启、关闭两种状态。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, a QCheckBox widgetis used to toggle the title of a window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QCheckBox, QApplicationfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): cb = QCheckBox('Show title', self) cb.move(20, 20) cb.toggle() cb.stateChanged.connect(self.changeTitle) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('QCheckBox') self.show() def changeTitle(self, state): if state == Qt.Checked: self.setWindowTitle('QCheckBox') else: self.setWindowTitle('') if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) Toggle buttonToggle button 是具备press和not press 两种状态的按钮。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create three toggle buttons.They will control the background color of a QFrame. Author: Jan BodnarWebsite: zetcode.com Last edited: November 2016"""import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QApplication)from PyQt5.QtGui import QColorclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.col = QColor(0, 0, 0) redb = QPushButton('Red', self) redb.setCheckable(True) redb.move(10, 10) redb.clicked[bool].connect(self.setColor) greenb = QPushButton('Green', self) greenb.setCheckable(True) greenb.move(10, 60) greenb.clicked[bool].connect(self.setColor) blueb = QPushButton('Blue', self) blueb.setCheckable(True) blueb.move(10, 110) blueb.clicked[bool].connect(self.setColor) self.square = QFrame(self) self.square.setGeometry(150, 20, 100, 100) self.square.setStyleSheet("QWidget &#123; background-color: %s &#125;" % self.col.name()) self.setGeometry(300, 300, 280, 170) self.setWindowTitle('Toggle button') self.show() def setColor(self, pressed): source = self.sender() if pressed: val = 255 else: val = 0 if source.text() == "Red": self.col.setRed(val) elif source.text() == "Green": self.col.setGreen(val) else: self.col.setBlue(val) self.square.setStyleSheet("QFrame &#123; background-color: %s &#125;" % self.col.name()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QSliderQSlider 滚动条 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a QSlider widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QSlider, QLabel, QApplication)from PyQt5.QtCore import Qtfrom PyQt5.QtGui import QPixmapclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): sld = QSlider(Qt.Horizontal, self) sld.setFocusPolicy(Qt.NoFocus) sld.setGeometry(30, 40, 100, 30) sld.valueChanged[int].connect(self.changeValue) self.label = QLabel(self) self.label.setPixmap(QPixmap('mute.png')) self.label.setGeometry(160, 40, 80, 30) self.setGeometry(300, 300, 280, 170) self.setWindowTitle('QSlider') self.show() def changeValue(self, value): if value == 0: self.label.setPixmap(QPixmap('mute.png')) elif value &gt; 0 and value &lt;= 30: self.label.setPixmap(QPixmap('min.png')) elif value &gt; 30 and value &lt; 80: self.label.setPixmap(QPixmap('med.png')) else: self.label.setPixmap(QPixmap('max.png')) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QProgressBar进度条 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a QProgressBar widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QProgressBar, QPushButton, QApplication)from PyQt5.QtCore import QBasicTimerclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.pbar = QProgressBar(self) self.pbar.setGeometry(30, 40, 200, 25) self.btn = QPushButton('Start', self) self.btn.move(40, 80) self.btn.clicked.connect(self.doAction) self.timer = QBasicTimer() self.step = 0 self.setGeometry(300, 300, 280, 170) self.setWindowTitle('QProgressBar') self.show() def timerEvent(self, e): if self.step &gt;= 100: self.timer.stop() self.btn.setText('Finished') return self.step = self.step + 1 self.pbar.setValue(self.step) def doAction(self): if self.timer.isActive(): self.timer.stop() self.btn.setText('Start') else: self.timer.start(100, self) self.btn.setText('Stop') if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QCalendarWidget日期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a QCalendarWidget widget.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QCalendarWidget, QLabel, QApplication)from PyQt5.QtCore import QDateclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): cal = QCalendarWidget(self) cal.setGridVisible(True) cal.move(20, 20) cal.clicked[QDate].connect(self.showDate) self.lbl = QLabel(self) date = cal.selectedDate() self.lbl.setText(date.toString()) self.lbl.move(130, 260) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('Calendar') self.show() def showDate(self, date): self.lbl.setText(date.toString()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-6 对话框 【Dialogs in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5_6%2F</url>
      <content type="text"><![CDATA[对话框窗口 或 对话框 是现代GUI应用中不可或缺的部分。对话框是人之间的对话，在计算机中，对话框是用于与应用交互的窗口。对话框用于输入数据、定义数据、改变应用设置等。 QInputDialogQInputDialog 提供简便地从用户获取单值的方法。输入值可以是string、数字 或 列表的一项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we receive data froma QInputDialog dialog. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QLineEdit, QInputDialog, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.btn = QPushButton('Dialog', self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) self.le = QLineEdit(self) self.le.move(130, 22) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Input dialog') self.show() def showDialog(self): text, ok = QInputDialog.getText(self, 'Input Dialog', 'Enter your name:') if ok: self.le.setText(str(text)) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QColorDialog用于选择颜色的对话框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we select a color valuefrom the QColorDialog and change the backgroundcolor of a QFrame widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QPushButton, QFrame, QColorDialog, QApplication)from PyQt5.QtGui import QColorclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): col = QColor(0, 0, 0) self.btn = QPushButton('Dialog', self) self.btn.move(20, 20) self.btn.clicked.connect(self.showDialog) self.frm = QFrame(self) self.frm.setStyleSheet("QWidget &#123; background-color: %s &#125;" % col.name()) self.frm.setGeometry(130, 22, 100, 100) self.setGeometry(300, 300, 250, 180) self.setWindowTitle('Color dialog') self.show() def showDialog(self): col = QColorDialog.getColor() if col.isValid(): self.frm.setStyleSheet("QWidget &#123; background-color: %s &#125;" % col.name()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QFontDialog字体对话框 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we select a font nameand change the font of a label. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QVBoxLayout, QPushButton, QSizePolicy, QLabel, QFontDialog, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): vbox = QVBoxLayout() btn = QPushButton('Dialog', self) btn.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed) btn.move(20, 20) vbox.addWidget(btn) btn.clicked.connect(self.showDialog) self.lbl = QLabel('Knowledge only matters', self) self.lbl.move(130, 20) vbox.addWidget(self.lbl) self.setLayout(vbox) self.setGeometry(300, 300, 250, 180) self.setWindowTitle('Font dialog') self.show() def showDialog(self): font, ok = QFontDialog.getFont() if ok: self.lbl.setFont(font) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QFileDialog文件对话框，选择文件或路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we select a file with aQFileDialog and display its contentsin a QTextEdit.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QMainWindow, QTextEdit, QAction, QFileDialog, QApplication)from PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.textEdit = QTextEdit() self.setCentralWidget(self.textEdit) self.statusBar() openFile = QAction(QIcon('open.png'), 'Open', self) openFile.setShortcut('Ctrl+O') openFile.setStatusTip('Open new File') openFile.triggered.connect(self.showDialog) menubar = self.menuBar() fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(openFile) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('File dialog') self.show() def showDialog(self): fname = QFileDialog.getOpenFileName(self, 'Open file', '/home') if fname[0]: f = open(fname[0], 'r') with f: data = f.read() self.textEdit.setText(data) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-5 事件和信号【Events and signals in PyQt5】]]></title>
      <url>%2F2017%2F04%2F19%2FPyQt5_5%2F</url>
      <content type="text"><![CDATA[这部分的将介绍PyQt5应用中的事件和信号处理。 事件【Events】所有的 GUI 应用都是事件驱动的。事件主要是由应用的用户产生，也可通过其他方法产生，比如：英特网连接、窗口管理器、定时器。当调用应用的exec_() 方法，应用进入主循环，主循环接受事件送往对应的处理对象。 事件模型中，三个组成部分： 事件源 事件对象 事件目标 事件源是状态改变的对象，由其产生事件。事件对象（事件）代表事件源的状态改变。事件目标是需要被通知发生变化的对象。事件源将事件处理委托给事件目标 PyQt5 使用独特的信号、槽机制处理事件。信号、槽用于与对象通信，当事件发生时便产生一个信号，槽可以是Python可调用对象。当信号产生时，其对应连接的槽将被调用。 信号、槽【Signals &amp; slots】例子：在PyQt5 中使用信号、槽1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we connect a signalof a QSlider to a slot of a QLCDNumber. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import (QWidget, QLCDNumber, QSlider, QVBoxLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lcd = QLCDNumber(self) sld = QSlider(Qt.Horizontal, self) vbox = QVBoxLayout() vbox.addWidget(lcd) vbox.addWidget(sld) self.setLayout(vbox) sld.valueChanged.connect(lcd.display) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Signal &amp; slot') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 例子中含有QLCDNumber 和 QSlider ，通过此句代码拖动滚动条改变lcd的显示。 1sld.valueChanged.connect(lcd.display) 将 valueChanged 信号与 Slider display 槽函数绑定。 发送者是发送信号的对象。接受者是接受信号的对象，槽是对信号做出反应的方法。 实现事件处理器 【Reimplementing event handler】PyQt5 中的事件处理经常需要重新实现事件处理器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we reimplement an event handler. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtCore import Qtfrom PyQt5.QtWidgets import QWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Event handler') self.show() def keyPressEvent(self, e): if e.key() == Qt.Key_Escape: self.close() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 实现了按键处理器，keyPressEvent 事件发送者 【Event sender】某些时候，知道信号的发送者很有帮助，因此PqQt5提供了sender()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we determine the event senderobject.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QPushButton, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): btn1 = QPushButton("Button 1", self) btn1.move(30, 50) btn2 = QPushButton("Button 2", self) btn2.move(150, 50) btn1.clicked.connect(self.buttonClicked) btn2.clicked.connect(self.buttonClicked) self.statusBar() self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Event sender') self.show() def buttonClicked(self): sender = self.sender() self.statusBar().showMessage(sender.text() + ' was pressed') if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 本例中有两个按钮，buttonClicked()方法通过sender确定是谁发生了点击事件。 触发信号【Emitting signals】展示如何自定义触发信号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we show how to emit asignal. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtCore import pyqtSignal, QObjectfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Communicate(QObject): closeApp = pyqtSignal() class Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.c = Communicate() self.c.closeApp.connect(self.close) self.setGeometry(300, 300, 290, 150) self.setWindowTitle('Emit signal') self.show() def mousePressEvent(self, event): self.c.closeApp.emit() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 创建一个 closeApp 信号，当鼠标键入时信号触发。此信号与close槽方法相连。 12self.c = Communicate()self.c.closeApp.connect(self.close)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[machine_learning]]></title>
      <url>%2F2017%2F04%2F14%2Fmachine_learning%2F</url>
      <content type="text"><![CDATA[normalization、standardization、regularization 定义区别http://blog.csdn.net/zyf89531/article/details/45922151 feature maphttps://www.zhihu.com/question/31318081 local response normalizationhttps://www.quora.com/What-is-local-response-normalization]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯面试]]></title>
      <url>%2F2017%2F04%2F11%2Finterview_tencent%2F</url>
      <content type="text"><![CDATA[早上大概9:30到的面试现场，签到等候的时候，心里在默默复习面试可能常问的问题。大概10:15分开始进去面试。一开始看到面试官，心情比较紧张，也不知到待会儿面试官会问我些什么呢。谨慎的递上简历后，简历官看了下我的简历。开始问我项目经历，科研方面的问题，还好都是自己做过的东西，介绍起来很轻松，怎么做的怎么说就是了。后来问了下学习和算法，面试官还想考察下我的代码功底，可惜，有些项目没有传到github上。 面试官对机器人挺感兴趣的，谈话中涉及到很多机器人方面的内容，还有机器学习上的一些问题。面试官感觉很亲切，像大哥哥一样。体验很好的一次面试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试知识点]]></title>
      <url>%2F2017%2F04%2F10%2Finterview_basics%2F</url>
      <content type="text"><![CDATA[操作系统部分进程、线程、协程、管程 概念和区别线程共享堆，同一内存空间 进程间通信 文件、锁 管道（半双工、父子进程间使用） 命名管道fifo（半双工、可以在无亲缘关系进程间通信） 信号量 信号 消息队列 共享内存 （只有映射为0时，内核才删除共享内存） 套接字 进程同步和互斥### 临界区 和 mutex 临界区只能在同一进程的线程中使用达到互斥，mutex可以在进程间使用达到互斥 锁、信号量、开关中断(硬件级)、管程 死锁概念中断 分类：软终端、硬中断 中断处理机制 请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回。 父子进程共享、fork 写时复制 共享代码段 数据空间、堆栈不同 文件指针 实际用户ID、实际组ID、有效用户ID、有效组ID 添加组ID、进程组ID、会话ID、控制终端 当前工作目录、根目录、文件屏蔽字、信号屏蔽和排列、环境变量、共享存储段。 ## 页式管理、段式管理、段页式管理。 数据库范式 1-范式 属性值不可再分裂成更小的部分 2-范式 1-范式的基础上，每个属性都依赖于关系模式R中的某个候选键 3-范式 消除了传递依赖的2-范式 BCNF范式 在1-范式的基础上，消除了传递依赖，即每个属性不传递依赖于R的候选键 函数依赖 平凡依赖 X→Y， Y包含X 非平凡依赖 X→Y， Y不包含X 多值依赖 设R(U)是属性集U上的一个关系模式。X，Y，Z是的U的子集,并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r,给定的一对(x，z)值有一组Y的值，这组值仅仅决定于x值而与z值无关。 平凡多值依赖 ，当z为空 非平凡多值依赖 游标（回滚操作）触发器 事前触发器、事后触发器 语句级出发、行级触发 SQL注入索引计算机网络TCP、UDP 区别 TCP 有连接、可靠的字节流服务、超时重发、检验数据、流量控制。 UDP 数据报协议、不可靠 tcp 特点 快重传、慢启动、超时重传 TCP 3次握手 TCP 4次挥手 设计模式 软件测试 黑盒测试白盒测试面向对象小点 结构体对齐问题，sizeof() 内联函数 宏只是简单的替换]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java基础知识点目录]]></title>
      <url>%2F2017%2F04%2F06%2Fjava_index%2F</url>
      <content type="text"><![CDATA[参考资料： 《The Java® Virtual Machine Specification(Java SE 8 Edition)》《Java 虚拟机规范(Java SE 7)》中文版本Java 虚拟机规范 《The Java® Virtual Machine Specification(Java SE 8 Edition)》《The Java Language Specification,Java SE 7 Edition》Java 语言规范 《Oracle JRockit The Definitive Guide》 oracle 出品 JRockit 虚拟机高级使用指南， 2010年7月出版 《Inside the Java 2 Virtual Machine,Second Edition》 2000年1月出版， 《Java Performance》 只有第3、4、7 章与Java虚拟机相关，是从操作系统到基于Java的上层程序性能度量和调优的全面介绍，其中设计Java虚拟机的内容具备一定的深度和可实践性。 高级语言虚拟机圈子： 高级语言虚拟机圈子：http://hllvm.group.iteye.com/ Java 体系结构传统意义上，Sun官方定义的Java 体系结构包括： Java 程序设计语言 Java 虚拟机 Class 文件格式 Java API 类库 Jdk 与 JRE 的关系 Java 的4个版本 Java Card：支持Java小程序(Applets)运行在小内存设备上。 Java ME ： 对Java API 有所精简，加入对移动设备的支持。 Java SE ： 提供完整的Java 核心 API，桌面级应用。 Java EE ： 企业开发，在Java SE API 之外，增加了大量的扩充并提供了相关的部署支持。 扩展一般以javax.\作为包名， 以java. 为包名的都是Java SE API，后来历史发展，一部分扩展包也被划分为核心包了，所以部分核心包也以javax.为包名* Java 发展JDK 1.2 中细分为J2EE\J2SE\J2ME三个方向，内置了Classic VM、Hotspot VM、Exact VM(只在solaris平台上)，后两个VM 内置 JIT 编译器。添加了 strictfp 关键字与collections 集合类。 JDK 1.3 主要改进了类库，JNDI 开始作为一项平台级服务提供，使用 CORBA IIOP 实现 RMI 通信协议， 改进了Java2D API, 新增JavaSound类库。 JDK 1.4 Java走向成熟的标志！新特性：正则表达式、异常链、NIO、日志类、XML解析器、XSLT转换器等。 JDK 1.5 主要改进易用性，出现的新特性主要有：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环(foreach)。在虚拟机和API上，改进了Java的内存模型、提供了java.util.concurrent并发包。 JDK 1.6 转为 Java EE、 Java SE、 Java ME 的命名方式。提供动态语言支持（内置 mozilla JavaScript rhino引擎），提供编译API 和 微型HTTP服务器API等，同时对Java虚拟机内部改动：锁与同步、垃圾收集、类加载等方面。 JDK 1.7 新的G1收集器、加强对非Java语言的调用支持，升级类加载架构等。 JDK 1.8 特性：接口添加非抽象的方法实现(default 关键字)、Lambda表达式、函数式接口、方法构造函数引用、全新的日期API、多重注解。 Java 虚拟机发展Sun Classic VM/Exact VMClassic VM刚开始不提供JIT编译器，后来通过外挂的方式提供JIT编译器。JIT编译器会完全接管虚拟机的执行系统，解释器和JIT编译器不能同时工作。VM的虚拟机，它的执行系统已经具备现代高性能虚拟机的雏形：如两级即时编译器、编译器与解释器混合工作模式等。Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。 Hotspot VM优点：热点代码探测技术、JIT编译器、混合的运行时系统。后与JRockit vm 整合，添加JRockit的垃圾回收器、MissionControl服务。 Sun Mobile-Embedded VM\Meta-Circular VM移动设备上的 VM BEA JRockit\IBM J9 VMAzul VM\BEA Liquid VMAzul VM 专有系统上的VM，Azul systems 公司的 Zing JVM 提供接近Vega系统的特性。 Liquid VM 不需要操作系统的支持，越过操作系统直接控制硬件。 Apache Harmony\ Dalvik VM这两个都不算正规的VM Microsoft JVM微软的JVM 为了在IE 中支持Java小程序，后来抛弃不开发了。 混合语言Clojure、JRuby、Java、Groovy 多核并行JDK 1.7 加入的包java.util.concurrent.forkjoin 扩充了并发框架java.util.concurrent。fork/join 模式！ Sumatra 项目提供java接入cpu运算能力的工具。 64位虚拟机64位虚拟机性能比32位差？感觉很奇怪。64位的优点是能够提供更大的内存空间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[珠海宽德科技面试]]></title>
      <url>%2F2017%2F04%2F05%2Finterview_wizardquant%2F</url>
      <content type="text"><![CDATA[面试过程 介绍个人的项目经验 java、操作系统、python等基础知识点 项目经验简单和面试官介绍了下个人的项目经验，说的并不好，还是需要练习，各种项目指标细节我都没有谈到，只是简单说了下个人负责的功能。 Java Java 反射能够实现什么？ Java gc 如何确定对象需要被清除？ Java gc 为什么要分成老年代和新生代？ volatile 修饰符作用？ synchronized修饰符作用？ Java 无锁类型？ 这个没听清 操作系统 cpu 调度方式 父子进程fork后共享什么？ 进程和线程的区别？ 进程间通信有几种？ 子进程 fork 后进程空间，CopyOnWrite！！！ 中断分类，时钟中断 python set 是怎么实现的？ 如何求 set 的交集？ 数据库 如何实现读写分离？ 数据库实现同步方式。 问的都挺基础，自己没搞清楚。。。应该也跪了！回家养猪，养猪~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[珠海习悦面试]]></title>
      <url>%2F2017%2F04%2F05%2Finterview_thinkjoy%2F</url>
      <content type="text"><![CDATA[记一次略感神奇的面试经历~上来先自我介绍了一下然后介绍在做的深度学习抓取物体的实验，介绍个人的深度学习方面看的论文、学习实践情况等 有点囧啊，其他的问题都没问。。。第一次想主动和面试官说说话！！！可能面试官没面试过几次？也许吧 后来也没什么消息了，好像进了人才库，什么鬼嘛，想找个实习难了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-4 布局管理【Layout management in PyQt5】]]></title>
      <url>%2F2017%2F04%2F04%2FPyQt5_4%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 布局管理是GUI 编程一个重要的方面。布局管理是如何在窗口中安排部件的方法。可以通过设置绝对位置、或使用布局类这两种基本方式管理布局。 绝对布局【Absolute positioning】在像素级别设置每个部件的位置和大小。当使用绝对布局时，需要理解以下的限制： 当改变窗口大小的时候，部件的大小和位置不能更改。 应用也许在不同平台上显示效果不一致。 改变应用的字体也许会毁掉布局。 如果决定改变布局，需要重新设计布局，非常消耗时间、乏味 下面的例子将按绝对布局放置widgets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows three labels on a windowusing absolute positioning. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QLabel, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lbl1 = QLabel('Zetcode', self) lbl1.move(15, 10) lbl2 = QLabel('tutorials', self) lbl2.move(35, 40) lbl3 = QLabel('for programmers', self) lbl3.move(55, 70) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Absolute') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 使用 move（）方法设置widgets 的位置。 本例子中的widgets都是label，通过设置（x，y） 坐标设置其位置。坐标系统的原点位于左上角。x坐标轴方向由左向右，y坐标轴由上向下。 12lbl1 = QLabel('Zetcode', self)lbl1.move(15, 10) label widget 位置是 x=15, y = 10 盒式布局 【Box layout】布局类管理布局更加灵活和实际。QHBoxLayout 和 QVBoxLayout 是使weigets 成水平、垂直排列的基类。 Imagine that we wanted to place two buttons in the right bottom corner. To create such a layout, we will use one horizontal and one vertical box. To create the necessary space, we will add a stretch factor. 12okButton = QPushButton("OK") cancelButton = QPushButton("Cancel") 创建两个按钮1234hbox = QHBoxLayout()hbox.addStretch(1)hbox.addWidget(okButton)hbox.addWidget(cancelButton) 创建水平布局并添加stretch因子和两个按钮。stretch 添加在两个按钮之前一个可伸缩空间，能够使两个按钮移动到窗口右边。 123vbox = QVBoxLayout()vbox.addStretch(1)vbox.addLayout(hbox) 创建一个垂直布局，添加stretch 和 hbox布局，stretch 会令hbox 位于窗口的底部。最后，效果如下： 栅格布局 【QGridLayout】最通用的布局类是栅格布局，按行列的方式分割空间。QGridLayout 实现了栅格布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a skeletonof a calculator using a QGridLayout.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QGridLayout, QPushButton, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout() self.setLayout(grid) names = ['Cls', 'Bck', '', 'Close', '7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', '.', '=', '+'] positions = [(i,j) for i in range(5) for j in range(4)] for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) self.move(300, 150) self.setWindowTitle('Calculator') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 声明在grid中的位置： 123456for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) 效果如： Review example在grid 布局中，widgets 可以横垮多个行列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a bitmore complicated window layout usingthe QGridLayout manager. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): title = QLabel('Title') author = QLabel('Author') review = QLabel('Review') titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QTextEdit() grid = QGridLayout() grid.setSpacing(10) grid.addWidget(title, 1, 0) grid.addWidget(titleEdit, 1, 1) grid.addWidget(author, 2, 0) grid.addWidget(authorEdit, 2, 1) grid.addWidget(review, 3, 0) grid.addWidget(reviewEdit, 3, 1, 5, 1) self.setLayout(grid) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('Review') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 12grid = QGridLayout()grid.setSpacing(10) 创建grid layout 并设置widgets 间距离spacing grid.addWidget(reviewEdit, 3, 1, 5, 1) 设置 reviewEdit 位于第三行，第一列，占5行，1列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-3 PyQt5 的菜单、工具栏【Menus and toolbars in PyQt5】]]></title>
      <url>%2F2017%2F03%2F24%2FPyQt5_3%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 这一部分将会介绍如何创建菜单、工具栏。 菜单是一组命令的集合，以菜单栏的形式展现。工具栏带有应用的一些命令的按钮。 主窗口【Main Window】QMainWindow类提供了应用主窗口，能够用于创建典型的具有状态栏、工具栏和菜单栏的应用模式。 状态栏【Statusbar】状态栏是用于显示状态信息的部件(widget) 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a statusbar.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.statusBar().showMessage('Ready') self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Statusbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 状态栏在QMainWindow下创建。1self.statusBar().showMessage('Ready') 通过调用QtGui.QMainWindow的statusBar()方法获得状态栏，首次调用将创建一个状态栏，后续的调用会返回状态栏对象。showMessage() 方法在状态栏显示消息。 菜单栏 【Menubar】菜单栏是常用的GUI应用部分。它包含一组的不同的命令菜单（Mac 的菜单栏有点不同）。为了获得相似的效果，可以使用此方法menubar.setNativeMenuBar(False)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a menubar. Themenubar has one menu with an exit action.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(qApp.quit) self.statusBar() menubar = self.menuBar() menubar.setNativeMenuBar(False) fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Menubar') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上面的例子中，新建一个带有菜单的菜单栏。菜单包括一个终止应用的action。同时也新建一个状态栏。action可以通过Ctrl+Q 快捷键触发。 123exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q')exitAction.setStatusTip('Exit application') QAction 是菜单栏、工具栏上操作的抽象，可以自定义快捷键。上面的代码创建一个具有图标、“Exit”标签、与快捷键的action。第三行设置状态提示，当鼠标悬停在菜单项上时就会触发。 1exitAction.triggered.connect(qApp.quit) 当选择特定的action，触发特定的 signal，此 signal 与 QApplication widget的quit() 方法连接，会使应用退出。 123menubar = self.menuBar()fileMenu = menubar.addMenu('&amp;File')fileMenu.addAction(exitAction) menuBar() 方法创建菜单栏，上面代码中创建了一个 file 菜单，与一个 exitAction 操作。 工具栏 Toolbar应用中的所有命令成组的方式放置于菜单中。 工具栏提供了快速访问常用命令的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorialThis program creates a toolbar.The toolbar has one action, whichterminates the application, if triggered.author: Jan Bodnarwebsite: zetcode.comlast edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.triggered.connect(qApp.quit) self.toolbar = self.addToolBar('Exit') self.toolbar.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Toolbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上述例子，创建简单的工具栏（带有一个退出action）。 123exitAction = QAction(QIcon('exit24.png'), 'Exit', self)exitAction.setShortcut('Ctrl+Q')exitAction.triggered.connect(qApp.quit) 类似于上述的菜单栏，创建 action 对象（具有标签、图标、快捷键），triggered 信号连接到 exit()方法。 12self.toolbar = self.addToolBar('Exit')self.toolbar.addAction(exitAction) 创建工具栏。 集成到一起 Putting it together在本节的最后一个例子中，展示一个带有菜单栏、工具栏、状态栏和 中央widget 的应用例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) exitAction = QAction(QIcon('exit24.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(self.close) self.statusBar() menubar = self.menuBar() fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) toolbar = self.addToolBar('Exit') toolbar.addAction(exitAction) self.setGeometry(300, 300, 350, 250) self.setWindowTitle('Main window') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例子创建了经典的带有菜单栏、工具栏、状态栏的GUI应用。 12textEdit = QTextEdit()self.setCentralWidget(textEdit) 文本编辑控件，处于窗口中心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-2 第一个程序 【First programs】]]></title>
      <url>%2F2017%2F03%2F21%2FPyQt5_2%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 简单示例该例子显示一个小窗口。可以利用这个窗口完成很多事情，比如调整大小、最大化、最小化。而这需要大量的代码。已经内置了此部分代码，因为此部分代码在大多数程序中都需要使用，不需要重复编码此部分功能。PyQt5是一个高级的工具集，如果使用低级别的工具集开发编码，以下的例子很可能产生上百行代码。 1234567891011121314151617181920212223242526272829#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a simplewindow in PyQt5.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetif __name__ == '__main__': app = QApplication(sys.argv) w = QWidget() w.resize(250, 150) w.move(300, 300) w.setWindowTitle('Simple') w.show() sys.exit(app.exec_()) 上面代码展示一个小窗口 12import sysfrom PyQt5.QtWidgets import QApplication, QWidget 导入必要的模块。基本的小部件在PyQt5.QtWidgets 模块中。 1app = QApplication(sys.argv) 每个PyQt5 应用必须创建一个application 对象。sys.argv 参数是命令行参数的列表。Python 脚本可以从shell运行，通过这种方式可以控制脚本的启动方式。1w = QWidget() QWidget 部件是PyQt5中所有用户界面对象的基类。我们提供了默认的QWidget构造器，默认的构造器没有父级元素。（没有父级元素的部件称为窗口）1w.resize(250, 150) resize() 方法调整部件的大小. 宽度：250px； 高度：150px1w.move(300, 300) move()把部件移动到坐标为（300，300）处。1w.setWindowTitle('Simple') 设置窗口的标题。表示在标题栏展示。1w.show() show()在窗口上显示部件。部件首先在内存中创建，然后在屏幕上展示。1sys.exit(app.exec_()) 最后，进入应用主循环。事件处理从此调用开始。主循环从窗口系统接收事件、把分发事件到应用部件。当exit()调用或主部件销毁即引发主循环结束。sys.exit() 方法确保干净的退出，通知系统应用如何退出。 exec_() 方法包含一个下划线。 因为exec 是Python的关键字,因此使用exec_()代替。 应用程序图标 (application icon)应用图标是标题栏左上角显示的小图像，接下来的例子会教大家如何在PyQt5中实现应用图标，顺带介绍一些新的方法调用。 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows an iconin the titlebar of the window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetfrom PyQt5.QtGui import QIconclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 300, 220) self.setWindowTitle('Icon') self.setWindowIcon(QIcon('./image/web.png')) self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 提示 （Tooltip）对每一个部件可以提供一个帮助提示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a tooltip on a window and a button.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication)from PyQt5.QtGui import QFont class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): QToolTip.setFont(QFont('SansSerif', 10)) self.setToolTip('This is a &lt;b&gt;QWidget&lt;/b&gt; widget') btn = QPushButton('Button', self) btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') btn.resize(btn.sizeHint()) btn.move(50, 50) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Tooltips') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 本例中展现了如何为PyQt5 部件添加 tooltip。 1QToolTip.setFont(QFont('SansSerif', 10)) 此静态方法设置tooltop渲染的字体，这里使用了SansSerif字体,大小为10px。 1self.setToolTip(&apos;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&apos;) 使用setToolTip 设置 tooltip， 可以使用富文本格式。 12btn = QPushButton('Button', self)btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') 添加push button 部件，及为push button 设置tooltip。 12btn.resize(btn.sizeHint())btn.move(50, 50) button 在窗口中重新设置大小、移动位置。 sizeHint() 使得 button 能够获得一个推荐适当的大小。 Figure: Tooltip 关闭窗口关闭窗口最明显的方式就是“点击标题栏的x标记”。在下一个例子中，我们会展示如何通过编码的方式关闭窗口。我们会开始接触到signals(信号)和 slots(槽) 。 下面是QPushButton 部件的构造函数。1QPushButton(string text, QWidget parent = None) text 参数是button上显示的文本。parent 是放置 button 的部件(widget). 在本例中他就是一个QWidget。应用中的Widegets形成层次结构，大多数Widget都有其parent，没有parent的Widgets是顶层的窗口. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a quitbutton. When we press the button,the application terminates. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QPushButton, QApplicationfrom PyQt5.QtCore import QCoreApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): qbtn = QPushButton('Quit', self) qbtn.clicked.connect(QCoreApplication.instance().quit) qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Quit button') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例中，创建了一个退出按钮，点击按钮，程序即退出。1from PyQt5.QtCore import QCoreApplication 需要导入QtCore中的包 1qbtn = QPushButton('Quit', self) 我们新建了一个QPushButton的实例。构造函数的第一个参数是按钮的标签，第二个参数是widget的parent。此处的parent是继承的QWidget对象。 1qbtn.clicked.connect(QCoreApplication.instance().quit) PyQt5的事件处理系统构建与 signal 和 slot 机制之上。如果我们点击按钮，信号就会被激发。slot 可以是一个Qt槽、或者python 可调用对象。QCoreApplication 包括一个主事件循环（处理和分发事件循环）；instance()方法返回一个当前实例。注意：QCoreApplication 是与 QApplication 一起创建的。clicked信号连接到quit()方法【quit方法用于结束应用】。接收者（push button）和发送者（application object）中负责互相通讯。 消息框（Message Box）默认情况下，如果点击标题栏的关闭按钮（x），QWidget 将被关闭。在某些情况下需要对这种行为进行修改，比如：编辑器中有仍未保存的被修改的文件，应该在关闭时出现一个确认行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program shows a confirmation message box when we click on the closebutton of the application window. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Message box') self.show() def closeEvent(self, event): reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 当关闭此QWidget时，触发QCloseEvent事件，通过重写closeEvent()事件控制方法修改默认的关闭行为。123reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) 显示一个带有两个按钮的消息框（yes 和 no）。第一个 字符串 参数在标题栏显示。第二个 字符串 参数是在对话框中显示的，第三个参数定义了出现在消息框中的按钮。最后一个参数定义默认的按钮。返回值传递给reply。 1234if reply == QtGui.QMessageBox.Yes: event.accept()else: event.ignore() 此处根据返回值判断是否关闭窗口，点击“yes”即接受事件，关闭widget和终止应用。否者，忽视此事件。 屏幕居中（centering window on the screen）此例展示如何在屏幕居中显示应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program centers a window on the screen. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) self.center() self.setWindowTitle('Center') self.show() def center(self): qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() qr.moveCenter(cp) self.move(qr.topLeft()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QtGui.QDesktopWidget 类提供了用户桌面的相关信息，包括桌面尺寸。 1self.center() 此方法实现了将程序移到屏幕的中央。 1qr = self.frameGeometry() 获得主窗口的方框描述，包括了任何窗口框。 1cp = QDesktopWidget().availableGeometry().center() 获得屏幕geometry，通过geometry获得屏幕的中心位置。 1qr.moveCenter(cp) 将窗口的中心位置移动到屏幕的中心，窗口的大小并不发生变化 1self.move(qr.topLeft()) 移动窗口的左上角到移动到qr的左上角，这样窗口就在屏幕的正中央了。 这部分介绍了一些基本PyQt5 知识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-1 简介 【Introduction】]]></title>
      <url>%2F2017%2F03%2F18%2FPyQt5_1%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 关于 PyQt5 【About PyQt5】PyQt5 是Digia的Qt5应用框架的python绑定实现。在 Python2 和 Python3 环境下皆可用。本教程使用 Python3。Qt 是最强大的GUI库之一。PyQt5的官方网站是www.riverbankcomputing.co.uk/news。PyQt5 由 Riverbank Computing 开发并维护。 PyQt5 以一系列Python模块的形式实现，其具有620个以上的类和6000个函数、方法。它是个跨平台的工具集（Unix、windows、mac）。PyQt5使用2个发行协议（GPL 和 商业协议） PyQt5 划分为以下几个模块： QtCoreQtCore 模块包含了核心的非GUI功能。此模块用于处理 time、files与 directories、不同的数据类型、流、URLs、mine types、线程或进程。 QtGuiQtGui 包括集成的窗口系统、事件处理、2D Graphics、basic imaging、字体、文本。 QtWidgetsQtWidgets 提供基本UI元素（以类的方式）创建典型的桌面用户界面。 QtMultimediaQtMultimedia 包括处理多媒体内容的类和访问camera、radio功能的Api QtBluetookQtBluetooh 模块包括蓝牙的扫描、链接及交互功能 QtNetworkQtNetwork 模块用于网络编程。此模块实现了TCP/IP 和 UDP 客户端、服务器使得网络编程更加简单和可移植。 QtPositioningQtPositioning 用于从多种源头获取位置信息；比如 satellite、Wifi、或文本文件。 EnginioEnginio 提供了client-side library用于访问Qt Cloud Services Managed Application Runtime。 QtWebSocketsQtWebSockets 实现了 WebSocket 协议 QtWebkitQtWebkit 提供了一个基于WebKit2库的web浏览器实现。 QtWebkitWidgetsQtWebkitWidgets 提供了在QtWidgets应用中使用的基于Webkit1的浏览器。 QtXmlQtXml 用于处理xml文件，此模块提供了基于SAX和DOM 的api QtSvgQtSvg 模块用于显示SVG文件。Scalable Vector Graphics (SVG) 是一种用XML描述二维图像、图形应用的语言。 QtSqlQtSQL 用于数据库相关工作。 QtTestQtTest 用于 PyQt5 应用的单元测试。 PyQt4 和 PyQt5 的区别 【Difference between PyQt4 and PyQt5】PyQt5 并不向后兼容（向下兼容）PyQt4; PyQt5 中发生了几大显著变化。然而把旧版本的代码重构到新的库中并不十分困难。PyQt5与PyQt4 的区别具体为： Python 的模块重新组织。一些模块被丢弃了（比如QtScript）,有些被划分到子模块中（比如QtGui、 QtWebKit）。 引入了新的模块，包括 QtBluetooth， QtPositioning、Enginio。 PyQt5 只支持新式的“信号-槽”事件处理机制。SIGNAL() 和 SLOT() 调用不再被支持。 PyQt5 不再支持任何在Qt v5.0被声明为deprecated（不提倡使用）或obsolete（废弃）的 Qt API。 PythonPython 是一种高级、动态、通用、跨平台、解释性、面向对象的编程语言。 Python的设计目的是突出程序员的效率和代码可读性。Python最开始由 Guido van Rossum 开发，于1991年首次发布。Python受ABC、Haskell、Java、Lisp、Icon、Perl启发。Python 简洁抽象，最直观的特性之一就是其代码使用缩进代替分号和花括号。Python目前有两大分支-Python2.x、Python3.x，Python3.x打破了向后兼容性，其目的是修正存在的设计错误，使得语言更加干净。Python由世界上的志愿者进行维护，它是开源的，Python是学习编程的理想入门语言。 本教程使用Python3.x 版本。 Python支持多种编程类型。它并不规范于特定的范式。Python 支持面向对象 与过程化编程。也提供有限的函数式编程支持。 Python的官方站点是 python.org Perl、Python、 Ruby 是广泛使用的脚本语言。它们存在诸多相同点；互相竞争。 本章节是PyQt5 工具集的介绍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[First Blog]]></title>
      <url>%2F2017%2F03%2F15%2Fhello%2F</url>
      <content type="text"><![CDATA[不可避俗的来一句：hello world!很想做个人博客，静态博客工具提供了一种很廉价的创建博客方式！在pelican、hugo、hexo三者中，我最终选择了hexo 与其中的 next 主题。真的很感谢hexo 与next主题的创建者们！！！！ 原本有想法自己做一个~但是自从看到这么优秀的框架后，就打消了这个念头！！！界面很优秀、很有趣！ 配置结合github 提供的 pages 服务构建个人网站。简单记录一下配置过程： 安装 node\npm这个参考网上教程就好，注意设置环境变量 安装 hexo123456789101112# 安装 hexonpm install hexo-cli -g# 初始化博客hexo init &lt;博客位置&gt;cd &lt;博客位置&gt;# 安装相应依赖npm install# 本地搜索插件npm install hexo-generator-searchdb --save# 启动ｈｅｘｏ服务器hexo server 安装 next 主题12$ cd &lt;博客位置&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 注意将 next中的.git 目录删掉，因为之后要用自己的git仓库托管。 hexo 博客设置hexo 博客配置文件位于 &lt;博客位置&gt;/_config.yml 修改以下项目，根据自己需要修改：12345678title: &lt;博客标题&gt;subtitle: &lt;博客子标题&gt;description: &lt;博客描述&gt;author: &lt;你的名字&gt;language: zh-Hansurl: &lt;个人博客url&gt; 启用next主题1theme: next 配置git-pages位置123456# Deployment## Docs: 设置部署位置，此处使用git-pages服务deploy: type: git repo: git@github.com:dandan32/dandan32.github.io.git branch: master 配置本地搜索123456# 搜索设置search: path: search.xml field: post format: html limit: 10000 主题博客配置参考官方教程]]></content>
    </entry>

    
  
  
</search>
