<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[PyQt5-4 布局管理【Layout management in PyQt5】]]></title>
      <url>%2F2017%2F04%2F04%2FPyQt5-4%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 布局管理是GUI 编程一个重要的方面。布局管理是如何在窗口中安排部件的方法。可以通过设置绝对位置、或使用布局类这两种基本方式管理布局。 绝对布局【Absolute positioning】在像素级别设置每个部件的位置和大小。当使用绝对布局时，需要理解以下的限制： 当改变窗口大小的时候，部件的大小和位置不能更改。 应用也许在不同平台上显示效果不一致。 改变应用的字体也许会毁掉布局。 如果决定改变布局，需要重新设计布局，非常消耗时间、乏味 下面的例子将按绝对布局放置widgets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows three labels on a windowusing absolute positioning. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QLabel, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lbl1 = QLabel('Zetcode', self) lbl1.move(15, 10) lbl2 = QLabel('tutorials', self) lbl2.move(35, 40) lbl3 = QLabel('for programmers', self) lbl3.move(55, 70) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Absolute') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 使用 move（）方法设置widgets 的位置。 本例子中的widgets都是label，通过设置（x，y） 坐标设置其位置。坐标系统的原点位于左上角。x坐标轴方向由左向右，y坐标轴由上向下。 12lbl1 = QLabel('Zetcode', self)lbl1.move(15, 10) label widget 位置是 x=15, y = 10 盒式布局 【Box layout】布局类管理布局更加灵活和实际。QHBoxLayout 和 QVBoxLayout 是使weigets 成水平、垂直排列的基类。 Imagine that we wanted to place two buttons in the right bottom corner. To create such a layout, we will use one horizontal and one vertical box. To create the necessary space, we will add a stretch factor. 12okButton = QPushButton("OK") cancelButton = QPushButton("Cancel") 创建两个按钮1234hbox = QHBoxLayout()hbox.addStretch(1)hbox.addWidget(okButton)hbox.addWidget(cancelButton) 创建水平布局并添加stretch因子和两个按钮。stretch 添加在两个按钮之前一个可伸缩空间，能够使两个按钮移动到窗口右边。 123vbox = QVBoxLayout()vbox.addStretch(1)vbox.addLayout(hbox) 创建一个垂直布局，添加stretch 和 hbox布局，stretch 会令hbox 位于窗口的底部。最后，效果如下： 栅格布局 【QGridLayout】最通用的布局类是栅格布局，按行列的方式分割空间。QGridLayout 实现了栅格布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a skeletonof a calculator using a QGridLayout.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QGridLayout, QPushButton, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout() self.setLayout(grid) names = ['Cls', 'Bck', '', 'Close', '7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', '.', '=', '+'] positions = [(i,j) for i in range(5) for j in range(4)] for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) self.move(300, 150) self.setWindowTitle('Calculator') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 声明在grid中的位置： 123456for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) 效果如： Review example在grid 布局中，widgets 可以横垮多个行列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a bitmore complicated window layout usingthe QGridLayout manager. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): title = QLabel('Title') author = QLabel('Author') review = QLabel('Review') titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QTextEdit() grid = QGridLayout() grid.setSpacing(10) grid.addWidget(title, 1, 0) grid.addWidget(titleEdit, 1, 1) grid.addWidget(author, 2, 0) grid.addWidget(authorEdit, 2, 1) grid.addWidget(review, 3, 0) grid.addWidget(reviewEdit, 3, 1, 5, 1) self.setLayout(grid) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('Review') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 12grid = QGridLayout()grid.setSpacing(10) 创建grid layout 并设置widgets 间距离spacing grid.addWidget(reviewEdit, 3, 1, 5, 1) 设置 reviewEdit 位于第三行，第一列，占5行，1列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-3 PyQt5 的菜单、工具栏【Menus and toolbars in PyQt5】]]></title>
      <url>%2F2017%2F03%2F24%2FPyQt5-3%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 这一部分将会介绍如何创建菜单、工具栏。 菜单是一组命令的集合，以菜单栏的形式展现。工具栏带有应用的一些命令的按钮。 主窗口【Main Window】QMainWindow类提供了应用主窗口，能够用于创建典型的具有状态栏、工具栏和菜单栏的应用模式。 状态栏【Statusbar】状态栏是用于显示状态信息的部件(widget) 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a statusbar.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.statusBar().showMessage('Ready') self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Statusbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 状态栏在QMainWindow下创建。1self.statusBar().showMessage('Ready') 通过调用QtGui.QMainWindow的statusBar()方法获得状态栏，首次调用将创建一个状态栏，后续的调用会返回状态栏对象。showMessage() 方法在状态栏显示消息。 菜单栏 【Menubar】菜单栏是常用的GUI应用部分。它包含一组的不同的命令菜单（Mac 的菜单栏有点不同）。为了获得相似的效果，可以使用此方法menubar.setNativeMenuBar(False)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a menubar. Themenubar has one menu with an exit action.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(qApp.quit) self.statusBar() menubar = self.menuBar() menubar.setNativeMenuBar(False) fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Menubar') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上面的例子中，新建一个带有菜单的菜单栏。菜单包括一个终止应用的action。同时也新建一个状态栏。action可以通过Ctrl+Q 快捷键触发。 123exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q')exitAction.setStatusTip('Exit application') QAction 是菜单栏、工具栏上操作的抽象，可以自定义快捷键。上面的代码创建一个具有图标、“Exit”标签、与快捷键的action。第三行设置状态提示，当鼠标悬停在菜单项上时就会触发。 1exitAction.triggered.connect(qApp.quit) 当选择特定的action，触发特定的 signal，此 signal 与 QApplication widget的quit() 方法连接，会使应用退出。 123menubar = self.menuBar()fileMenu = menubar.addMenu('&amp;File')fileMenu.addAction(exitAction) menuBar() 方法创建菜单栏，上面代码中创建了一个 file 菜单，与一个 exitAction 操作。 工具栏 Toolbar应用中的所有命令成组的方式放置于菜单中。 工具栏提供了快速访问常用命令的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorialThis program creates a toolbar.The toolbar has one action, whichterminates the application, if triggered.author: Jan Bodnarwebsite: zetcode.comlast edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.triggered.connect(qApp.quit) self.toolbar = self.addToolBar('Exit') self.toolbar.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Toolbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上述例子，创建简单的工具栏（带有一个退出action）。 123exitAction = QAction(QIcon('exit24.png'), 'Exit', self)exitAction.setShortcut('Ctrl+Q')exitAction.triggered.connect(qApp.quit) 类似于上述的菜单栏，创建 action 对象（具有标签、图标、快捷键），triggered 信号连接到 exit()方法。 12self.toolbar = self.addToolBar('Exit')self.toolbar.addAction(exitAction) 创建工具栏。 集成到一起 Putting it together在本节的最后一个例子中，展示一个带有菜单栏、工具栏、状态栏和 中央widget 的应用例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) exitAction = QAction(QIcon('exit24.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(self.close) self.statusBar() menubar = self.menuBar() fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) toolbar = self.addToolBar('Exit') toolbar.addAction(exitAction) self.setGeometry(300, 300, 350, 250) self.setWindowTitle('Main window') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例子创建了经典的带有菜单栏、工具栏、状态栏的GUI应用。 12textEdit = QTextEdit()self.setCentralWidget(textEdit) 文本编辑控件，处于窗口中心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-2 第一个程序 【First programs】]]></title>
      <url>%2F2017%2F03%2F21%2FPyQt5-2%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 简单示例该例子显示一个小窗口。可以利用这个窗口完成很多事情，比如调整大小、最大化、最小化。而这需要大量的代码。已经内置了此部分代码，因为此部分代码在大多数程序中都需要使用，不需要重复编码此部分功能。PyQt5是一个高级的工具集，如果使用低级别的工具集开发编码，以下的例子很可能产生上百行代码。 1234567891011121314151617181920212223242526272829#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a simplewindow in PyQt5.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetif __name__ == '__main__': app = QApplication(sys.argv) w = QWidget() w.resize(250, 150) w.move(300, 300) w.setWindowTitle('Simple') w.show() sys.exit(app.exec_()) 上面代码展示一个小窗口 12import sysfrom PyQt5.QtWidgets import QApplication, QWidget 导入必要的模块。基本的小部件在PyQt5.QtWidgets 模块中。 1app = QApplication(sys.argv) 每个PyQt5 应用必须创建一个application 对象。sys.argv 参数是命令行参数的列表。Python 脚本可以从shell运行，通过这种方式可以控制脚本的启动方式。1w = QWidget() QWidget 部件是PyQt5中所有用户界面对象的基类。我们提供了默认的QWidget构造器，默认的构造器没有父级元素。（没有父级元素的部件称为窗口）1w.resize(250, 150) resize() 方法调整部件的大小. 宽度：250px； 高度：150px1w.move(300, 300) move()把部件移动到坐标为（300，300）处。1w.setWindowTitle('Simple') 设置窗口的标题。表示在标题栏展示。1w.show() show()在窗口上显示部件。部件首先在内存中创建，然后在屏幕上展示。1sys.exit(app.exec_()) 最后，进入应用主循环。事件处理从此调用开始。主循环从窗口系统接收事件、把分发事件到应用部件。当exit()调用或主部件销毁即引发主循环结束。sys.exit() 方法确保干净的退出，通知系统应用如何退出。 exec_() 方法包含一个下划线。 因为exec 是Python的关键字,因此使用exec_()代替。 应用程序图标 (application icon)应用图标是标题栏左上角显示的小图像，接下来的例子会教大家如何在PyQt5中实现应用图标，顺带介绍一些新的方法调用。 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows an iconin the titlebar of the window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetfrom PyQt5.QtGui import QIconclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 300, 220) self.setWindowTitle('Icon') self.setWindowIcon(QIcon('./image/web.png')) self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 提示 （Tooltip）对每一个部件可以提供一个帮助提示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a tooltip on a window and a button.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication)from PyQt5.QtGui import QFont class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): QToolTip.setFont(QFont('SansSerif', 10)) self.setToolTip('This is a &lt;b&gt;QWidget&lt;/b&gt; widget') btn = QPushButton('Button', self) btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') btn.resize(btn.sizeHint()) btn.move(50, 50) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Tooltips') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 本例中展现了如何为PyQt5 部件添加 tooltip。 1QToolTip.setFont(QFont('SansSerif', 10)) 此静态方法设置tooltop渲染的字体，这里使用了SansSerif字体,大小为10px。 1self.setToolTip(&apos;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&apos;) 使用setToolTip 设置 tooltip， 可以使用富文本格式。 12btn = QPushButton('Button', self)btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') 添加push button 部件，及为push button 设置tooltip。 12btn.resize(btn.sizeHint())btn.move(50, 50) button 在窗口中重新设置大小、移动位置。 sizeHint() 使得 button 能够获得一个推荐适当的大小。 Figure: Tooltip 关闭窗口关闭窗口最明显的方式就是“点击标题栏的x标记”。在下一个例子中，我们会展示如何通过编码的方式关闭窗口。我们会开始接触到signals(信号)和 slots(槽) 。 下面是QPushButton 部件的构造函数。1QPushButton(string text, QWidget parent = None) text 参数是button上显示的文本。parent 是放置 button 的部件(widget). 在本例中他就是一个QWidget。应用中的Widegets形成层次结构，大多数Widget都有其parent，没有parent的Widgets是顶层的窗口. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a quitbutton. When we press the button,the application terminates. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QPushButton, QApplicationfrom PyQt5.QtCore import QCoreApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): qbtn = QPushButton('Quit', self) qbtn.clicked.connect(QCoreApplication.instance().quit) qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Quit button') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例中，创建了一个退出按钮，点击按钮，程序即退出。1from PyQt5.QtCore import QCoreApplication 需要导入QtCore中的包 1qbtn = QPushButton('Quit', self) 我们新建了一个QPushButton的实例。构造函数的第一个参数是按钮的标签，第二个参数是widget的parent。此处的parent是继承的QWidget对象。 1qbtn.clicked.connect(QCoreApplication.instance().quit) PyQt5的事件处理系统构建与 signal 和 slot 机制之上。如果我们点击按钮，信号就会被激发。slot 可以是一个Qt槽、或者python 可调用对象。QCoreApplication 包括一个主事件循环（处理和分发事件循环）；instance()方法返回一个当前实例。注意：QCoreApplication 是与 QApplication 一起创建的。clicked信号连接到quit()方法【quit方法用于结束应用】。接收者（push button）和发送者（application object）中负责互相通讯。 消息框（Message Box）默认情况下，如果点击标题栏的关闭按钮（x），QWidget 将被关闭。在某些情况下需要对这种行为进行修改，比如：编辑器中有仍未保存的被修改的文件，应该在关闭时出现一个确认行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program shows a confirmation message box when we click on the closebutton of the application window. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Message box') self.show() def closeEvent(self, event): reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 当关闭此QWidget时，触发QCloseEvent事件，通过重写closeEvent()事件控制方法修改默认的关闭行为。123reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) 显示一个带有两个按钮的消息框（yes 和 no）。第一个 字符串 参数在标题栏显示。第二个 字符串 参数是在对话框中显示的，第三个参数定义了出现在消息框中的按钮。最后一个参数定义默认的按钮。返回值传递给reply。 1234if reply == QtGui.QMessageBox.Yes: event.accept()else: event.ignore() 此处根据返回值判断是否关闭窗口，点击“yes”即接受事件，关闭widget和终止应用。否者，忽视此事件。 屏幕居中（centering window on the screen）此例展示如何在屏幕居中显示应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program centers a window on the screen. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) self.center() self.setWindowTitle('Center') self.show() def center(self): qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() qr.moveCenter(cp) self.move(qr.topLeft()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QtGui.QDesktopWidget 类提供了用户桌面的相关信息，包括桌面尺寸。 1self.center() 此方法实现了将程序移到屏幕的中央。 1qr = self.frameGeometry() 获得主窗口的方框描述，包括了任何窗口框。 1cp = QDesktopWidget().availableGeometry().center() 获得屏幕geometry，通过geometry获得屏幕的中心位置。 1qr.moveCenter(cp) 将窗口的中心位置移动到屏幕的中心，窗口的大小并不发生变化 1self.move(qr.topLeft()) 移动窗口的左上角到移动到qr的左上角，这样窗口就在屏幕的正中央了。 这部分介绍了一些基本PyQt5 知识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-1 简介 【Introduction】]]></title>
      <url>%2F2017%2F03%2F18%2FPyQt5-1%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 关于 PyQt5 【About PyQt5】PyQt5 是Digia的Qt5应用框架的python绑定实现。在 Python2 和 Python3 环境下皆可用。本教程使用 Python3。Qt 是最强大的GUI库之一。PyQt5的官方网站是www.riverbankcomputing.co.uk/news。PyQt5 由 Riverbank Computing 开发并维护。 PyQt5 以一系列Python模块的形式实现，其具有620个以上的类和6000个函数、方法。它是个跨平台的工具集（Unix、windows、mac）。PyQt5使用2个发行协议（GPL 和 商业协议） PyQt5 划分为以下几个模块： QtCoreQtCore 模块包含了核心的非GUI功能。此模块用于处理 time、files与 directories、不同的数据类型、流、URLs、mine types、线程或进程。 QtGuiQtGui 包括集成的窗口系统、事件处理、2D Graphics、basic imaging、字体、文本。 QtWidgetsQtWidgets 提供基本UI元素（以类的方式）创建典型的桌面用户界面。 QtMultimediaQtMultimedia 包括处理多媒体内容的类和访问camera、radio功能的Api QtBluetookQtBluetooh 模块包括蓝牙的扫描、链接及交互功能 QtNetworkQtNetwork 模块用于网络编程。此模块实现了TCP/IP 和 UDP 客户端、服务器使得网络编程更加简单和可移植。 QtPositioningQtPositioning 用于从多种源头获取位置信息；比如 satellite、Wifi、或文本文件。 EnginioEnginio 提供了client-side library用于访问Qt Cloud Services Managed Application Runtime。 QtWebSocketsQtWebSockets 实现了 WebSocket 协议 QtWebkitQtWebkit 提供了一个基于WebKit2库的web浏览器实现。 QtWebkitWidgetsQtWebkitWidgets 提供了在QtWidgets应用中使用的基于Webkit1的浏览器。 QtXmlQtXml 用于处理xml文件，此模块提供了基于SAX和DOM 的api QtSvgQtSvg 模块用于显示SVG文件。Scalable Vector Graphics (SVG) 是一种用XML描述二维图像、图形应用的语言。 QtSqlQtSQL 用于数据库相关工作。 QtTestQtTest 用于 PyQt5 应用的单元测试。 PyQt4 和 PyQt5 的区别 【Difference between PyQt4 and PyQt5】PyQt5 并不向后兼容（向下兼容）PyQt4; PyQt5 中发生了几大显著变化。然而把旧版本的代码重构到新的库中并不十分困难。PyQt5与PyQt4 的区别具体为： Python 的模块重新组织。一些模块被丢弃了（比如QtScript）,有些被划分到子模块中（比如QtGui、 QtWebKit）。 引入了新的模块，包括 QtBluetooth， QtPositioning、Enginio。 PyQt5 只支持新式的“信号-槽”事件处理机制。SIGNAL() 和 SLOT() 调用不再被支持。 PyQt5 不再支持任何在Qt v5.0被声明为deprecated（不提倡使用）或obsolete（废弃）的 Qt API。 PythonPython 是一种高级、动态、通用、跨平台、解释性、面向对象的编程语言。 Python的设计目的是突出程序员的效率和代码可读性。Python最开始由 Guido van Rossum 开发，于1991年首次发布。Python受ABC、Haskell、Java、Lisp、Icon、Perl启发。Python 简洁抽象，最直观的特性之一就是其代码使用缩进代替分号和花括号。Python目前有两大分支-Python2.x、Python3.x，Python3.x打破了向后兼容性，其目的是修正存在的设计错误，使得语言更加干净。Python由世界上的志愿者进行维护，它是开源的，Python是学习编程的理想入门语言。 本教程使用Python3.x 版本。 Python支持多种编程类型。它并不规范于特定的范式。Python 支持面向对象 与过程化编程。也提供有限的函数式编程支持。 Python的官方站点是 python.org Perl、Python、 Ruby 是广泛使用的脚本语言。它们存在诸多相同点；互相竞争。 本章节是PyQt5 工具集的介绍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello]]></title>
      <url>%2F2017%2F03%2F15%2Fhello%2F</url>
      <content type="text"><![CDATA[不可避俗的来一句：hello world! 很想做个人博客，静态博客工具提供了一种很廉价的创建博客方式！在pelican、hugo、hexo三者中，我最终选择了hexo 与其中的 next 主题。真的很感谢hexo 与next主题的创建者们！！！！ 原本有想法自己做一个~但是自从看到这么优秀的框架后，就打消了这个念头！！！界面很优秀、很有趣！]]></content>
    </entry>

    
  
  
</search>
