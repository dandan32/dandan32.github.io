<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[腾讯面试]]></title>
      <url>%2F2017%2F04%2F11%2Finterview_tencent%2F</url>
      <content type="text"><![CDATA[早上大概9:30到的面试现场，签到等候的时候，心里在默默复习面试可能常问的问题。大概10:15分开始进去面试。一开始看到面试官，心情比较紧张，也不知到待会儿面试官会问我些什么呢。谨慎的递上简历后，简历官看了下我的简历。开始问我项目经历，科研方面的问题，还好都是自己做过的东西，介绍起来很轻松，怎么做的怎么说就是了。后来问了下学习和算法，面试官还想考察下我的代码功底，可惜，有些项目没有传到github上。 面试官对机器人挺感兴趣的，谈话中涉及到很多机器人方面的内容，还有机器学习上的一些问题。面试官感觉很亲切，像大哥哥一样。体验很好的一次面试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统面试]]></title>
      <url>%2F2017%2F04%2F10%2Finterview_operatingsystem%2F</url>
      <content type="text"><![CDATA[进程、线程、协程、管程进程间通信 文件、锁 管道（半双工、父子进程间使用） 命名管道fifo（半双工、可以在无亲缘关系进程间通信） 信号量 信号 消息队列 共享内存 套接字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java基础知识点目录]]></title>
      <url>%2F2017%2F04%2F06%2Fjava_index%2F</url>
      <content type="text"><![CDATA[参考资料： 《The Java® Virtual Machine Specification(Java SE 8 Edition)》《Java 虚拟机规范(Java SE 7)》中文版本Java 虚拟机规范 《The Java® Virtual Machine Specification(Java SE 8 Edition)》《The Java Language Specification,Java SE 7 Edition》Java 语言规范 《Oracle JRockit The Definitive Guide》 oracle 出品 JRockit 虚拟机高级使用指南， 2010年7月出版 《Inside the Java 2 Virtual Machine,Second Edition》 2000年1月出版， 《Java Performance》 只有第3、4、7 章与Java虚拟机相关，是从操作系统到基于Java的上层程序性能度量和调优的全面介绍，其中设计Java虚拟机的内容具备一定的深度和可实践性。 高级语言虚拟机圈子： 高级语言虚拟机圈子：http://hllvm.group.iteye.com/ Java 体系结构传统意义上，Sun官方定义的Java 体系结构包括： Java 程序设计语言 Java 虚拟机 Class 文件格式 Java API 类库 Jdk 与 JRE 的关系 Java 的4个版本 Java Card：支持Java小程序(Applets)运行在小内存设备上。 Java ME ： 对Java API 有所精简，加入对移动设备的支持。 Java SE ： 提供完整的Java 核心 API，桌面级应用。 Java EE ： 企业开发，在Java SE API 之外，增加了大量的扩充并提供了相关的部署支持。 扩展一般以javax.\作为包名， 以java. 为包名的都是Java SE API，后来历史发展，一部分扩展包也被划分为核心包了，所以部分核心包也以javax.为包名* Java 发展JDK 1.2 中细分为J2EE\J2SE\J2ME三个方向，内置了Classic VM、Hotspot VM、Exact VM(只在solaris平台上)，后两个VM 内置 JIT 编译器。添加了 strictfp 关键字与collections 集合类。 JDK 1.3 主要改进了类库，JNDI 开始作为一项平台级服务提供，使用 CORBA IIOP 实现 RMI 通信协议， 改进了Java2D API, 新增JavaSound类库。 JDK 1.4 Java走向成熟的标志！新特性：正则表达式、异常链、NIO、日志类、XML解析器、XSLT转换器等。 JDK 1.5 主要改进易用性，出现的新特性主要有：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环(foreach)。在虚拟机和API上，改进了Java的内存模型、提供了java.util.concurrent并发包。 JDK 1.6 转为 Java EE、 Java SE、 Java ME 的命名方式。提供动态语言支持（内置 mozilla JavaScript rhino引擎），提供编译API 和 微型HTTP服务器API等，同时对Java虚拟机内部改动：锁与同步、垃圾收集、类加载等方面。 JDK 1.7 新的G1收集器、加强对非Java语言的调用支持，升级类加载架构等。 JDK 1.8 特性：接口添加非抽象的方法实现(default 关键字)、Lambda表达式、函数式接口、方法构造函数引用、全新的日期API、多重注解。 Java 虚拟机发展Sun Classic VM/Exact VMClassic VM刚开始不提供JIT编译器，后来通过外挂的方式提供JIT编译器。JIT编译器会完全接管虚拟机的执行系统，解释器和JIT编译器不能同时工作。VM的虚拟机，它的执行系统已经具备现代高性能虚拟机的雏形：如两级即时编译器、编译器与解释器混合工作模式等。Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。 Hotspot VM优点：热点代码探测技术、JIT编译器、混合的运行时系统。后与JRockit vm 整合，添加JRockit的垃圾回收器、MissionControl服务。 Sun Mobile-Embedded VM\Meta-Circular VM移动设备上的 VM BEA JRockit\IBM J9 VMAzul VM\BEA Liquid VMAzul VM 专有系统上的VM，Azul systems 公司的 Zing JVM 提供接近Vega系统的特性。 Liquid VM 不需要操作系统的支持，越过操作系统直接控制硬件。 Apache Harmony\ Dalvik VM这两个都不算正规的VM Microsoft JVM微软的JVM 为了在IE 中支持Java小程序，后来抛弃不开发了。 混合语言Clojure、JRuby、Java、Groovy 多核并行JDK 1.7 加入的包java.util.concurrent.forkjoin 扩充了并发框架java.util.concurrent。fork/join 模式！ Sumatra 项目提供java接入cpu运算能力的工具。 64位虚拟机64位虚拟机性能比32位差？感觉很奇怪。64位的优点是能够提供更大的内存空间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[珠海宽德科技面试]]></title>
      <url>%2F2017%2F04%2F05%2Finterview_wizardquant%2F</url>
      <content type="text"><![CDATA[面试过程 介绍个人的项目经验 java、操作系统、python等基础知识点 项目经验简单和面试官介绍了下个人的项目经验，说的并不好，还是需要练习，各种项目指标细节我都没有谈到，只是简单说了下个人负责的功能。 Java Java 反射能够实现什么？ Java gc 如何确定对象需要被清除？ Java gc 为什么要分成老年代和新生代？ volatile 修饰符作用？ synchronized修饰符作用？ Java 无锁类型？ 这个没听清 操作系统 cpu 调度方式 父子进程fork后共享什么？ 进程和线程的区别？ 进程间通信有几种？ 子进程 fork 后进程空间，CopyOnWrite！！！ python set 是怎么实现的？ 如何求 set 的交集？ 数据库 如何实现读写分离？ 数据库实现同步方式。 问的都挺基础，自己没搞清楚。。。应该也跪了！回家养猪，养猪~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[珠海习悦面试]]></title>
      <url>%2F2017%2F04%2F05%2Finterview_thinkjoy%2F</url>
      <content type="text"><![CDATA[记一次略感神奇的面试经历~上来先自我介绍了一下然后介绍在做的深度学习抓取物体的实验，介绍个人的深度学习方面看的论文、学习实践情况等 有点囧啊，其他的问题都没问。。。第一次想主动和面试官说说话！！！可能面试官没面试过几次？也许吧 后来也没什么消息了，好像进了人才库，什么鬼嘛，想找个实习难了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-4 布局管理【Layout management in PyQt5】]]></title>
      <url>%2F2017%2F04%2F04%2FPyQt5_4%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 布局管理是GUI 编程一个重要的方面。布局管理是如何在窗口中安排部件的方法。可以通过设置绝对位置、或使用布局类这两种基本方式管理布局。 绝对布局【Absolute positioning】在像素级别设置每个部件的位置和大小。当使用绝对布局时，需要理解以下的限制： 当改变窗口大小的时候，部件的大小和位置不能更改。 应用也许在不同平台上显示效果不一致。 改变应用的字体也许会毁掉布局。 如果决定改变布局，需要重新设计布局，非常消耗时间、乏味 下面的例子将按绝对布局放置widgets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows three labels on a windowusing absolute positioning. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QLabel, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lbl1 = QLabel('Zetcode', self) lbl1.move(15, 10) lbl2 = QLabel('tutorials', self) lbl2.move(35, 40) lbl3 = QLabel('for programmers', self) lbl3.move(55, 70) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Absolute') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 使用 move（）方法设置widgets 的位置。 本例子中的widgets都是label，通过设置（x，y） 坐标设置其位置。坐标系统的原点位于左上角。x坐标轴方向由左向右，y坐标轴由上向下。 12lbl1 = QLabel('Zetcode', self)lbl1.move(15, 10) label widget 位置是 x=15, y = 10 盒式布局 【Box layout】布局类管理布局更加灵活和实际。QHBoxLayout 和 QVBoxLayout 是使weigets 成水平、垂直排列的基类。 Imagine that we wanted to place two buttons in the right bottom corner. To create such a layout, we will use one horizontal and one vertical box. To create the necessary space, we will add a stretch factor. 12okButton = QPushButton("OK") cancelButton = QPushButton("Cancel") 创建两个按钮1234hbox = QHBoxLayout()hbox.addStretch(1)hbox.addWidget(okButton)hbox.addWidget(cancelButton) 创建水平布局并添加stretch因子和两个按钮。stretch 添加在两个按钮之前一个可伸缩空间，能够使两个按钮移动到窗口右边。 123vbox = QVBoxLayout()vbox.addStretch(1)vbox.addLayout(hbox) 创建一个垂直布局，添加stretch 和 hbox布局，stretch 会令hbox 位于窗口的底部。最后，效果如下： 栅格布局 【QGridLayout】最通用的布局类是栅格布局，按行列的方式分割空间。QGridLayout 实现了栅格布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a skeletonof a calculator using a QGridLayout.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QGridLayout, QPushButton, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout() self.setLayout(grid) names = ['Cls', 'Bck', '', 'Close', '7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', '.', '=', '+'] positions = [(i,j) for i in range(5) for j in range(4)] for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) self.move(300, 150) self.setWindowTitle('Calculator') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 声明在grid中的位置： 123456for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) 效果如： Review example在grid 布局中，widgets 可以横垮多个行列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a bitmore complicated window layout usingthe QGridLayout manager. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): title = QLabel('Title') author = QLabel('Author') review = QLabel('Review') titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QTextEdit() grid = QGridLayout() grid.setSpacing(10) grid.addWidget(title, 1, 0) grid.addWidget(titleEdit, 1, 1) grid.addWidget(author, 2, 0) grid.addWidget(authorEdit, 2, 1) grid.addWidget(review, 3, 0) grid.addWidget(reviewEdit, 3, 1, 5, 1) self.setLayout(grid) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('Review') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 12grid = QGridLayout()grid.setSpacing(10) 创建grid layout 并设置widgets 间距离spacing grid.addWidget(reviewEdit, 3, 1, 5, 1) 设置 reviewEdit 位于第三行，第一列，占5行，1列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-3 PyQt5 的菜单、工具栏【Menus and toolbars in PyQt5】]]></title>
      <url>%2F2017%2F03%2F24%2FPyQt5_3%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 这一部分将会介绍如何创建菜单、工具栏。 菜单是一组命令的集合，以菜单栏的形式展现。工具栏带有应用的一些命令的按钮。 主窗口【Main Window】QMainWindow类提供了应用主窗口，能够用于创建典型的具有状态栏、工具栏和菜单栏的应用模式。 状态栏【Statusbar】状态栏是用于显示状态信息的部件(widget) 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a statusbar.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.statusBar().showMessage('Ready') self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Statusbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 状态栏在QMainWindow下创建。1self.statusBar().showMessage('Ready') 通过调用QtGui.QMainWindow的statusBar()方法获得状态栏，首次调用将创建一个状态栏，后续的调用会返回状态栏对象。showMessage() 方法在状态栏显示消息。 菜单栏 【Menubar】菜单栏是常用的GUI应用部分。它包含一组的不同的命令菜单（Mac 的菜单栏有点不同）。为了获得相似的效果，可以使用此方法menubar.setNativeMenuBar(False)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a menubar. Themenubar has one menu with an exit action.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(qApp.quit) self.statusBar() menubar = self.menuBar() menubar.setNativeMenuBar(False) fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Menubar') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上面的例子中，新建一个带有菜单的菜单栏。菜单包括一个终止应用的action。同时也新建一个状态栏。action可以通过Ctrl+Q 快捷键触发。 123exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q')exitAction.setStatusTip('Exit application') QAction 是菜单栏、工具栏上操作的抽象，可以自定义快捷键。上面的代码创建一个具有图标、“Exit”标签、与快捷键的action。第三行设置状态提示，当鼠标悬停在菜单项上时就会触发。 1exitAction.triggered.connect(qApp.quit) 当选择特定的action，触发特定的 signal，此 signal 与 QApplication widget的quit() 方法连接，会使应用退出。 123menubar = self.menuBar()fileMenu = menubar.addMenu('&amp;File')fileMenu.addAction(exitAction) menuBar() 方法创建菜单栏，上面代码中创建了一个 file 菜单，与一个 exitAction 操作。 工具栏 Toolbar应用中的所有命令成组的方式放置于菜单中。 工具栏提供了快速访问常用命令的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorialThis program creates a toolbar.The toolbar has one action, whichterminates the application, if triggered.author: Jan Bodnarwebsite: zetcode.comlast edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon('exit.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.triggered.connect(qApp.quit) self.toolbar = self.addToolBar('Exit') self.toolbar.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Toolbar') self.show()if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 上述例子，创建简单的工具栏（带有一个退出action）。 123exitAction = QAction(QIcon('exit24.png'), 'Exit', self)exitAction.setShortcut('Ctrl+Q')exitAction.triggered.connect(qApp.quit) 类似于上述的菜单栏，创建 action 对象（具有标签、图标、快捷键），triggered 信号连接到 exit()方法。 12self.toolbar = self.addToolBar('Exit')self.toolbar.addAction(exitAction) 创建工具栏。 集成到一起 Putting it together在本节的最后一个例子中，展示一个带有菜单栏、工具栏、状态栏和 中央widget 的应用例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a skeleton ofa classic GUI application with a menubar,toolbar, statusbar, and a central widget. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) exitAction = QAction(QIcon('exit24.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(self.close) self.statusBar() menubar = self.menuBar() fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) toolbar = self.addToolBar('Exit') toolbar.addAction(exitAction) self.setGeometry(300, 300, 350, 250) self.setWindowTitle('Main window') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例子创建了经典的带有菜单栏、工具栏、状态栏的GUI应用。 12textEdit = QTextEdit()self.setCentralWidget(textEdit) 文本编辑控件，处于窗口中心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-2 第一个程序 【First programs】]]></title>
      <url>%2F2017%2F03%2F21%2FPyQt5_2%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 简单示例该例子显示一个小窗口。可以利用这个窗口完成很多事情，比如调整大小、最大化、最小化。而这需要大量的代码。已经内置了此部分代码，因为此部分代码在大多数程序中都需要使用，不需要重复编码此部分功能。PyQt5是一个高级的工具集，如果使用低级别的工具集开发编码，以下的例子很可能产生上百行代码。 1234567891011121314151617181920212223242526272829#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial In this example, we create a simplewindow in PyQt5.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetif __name__ == '__main__': app = QApplication(sys.argv) w = QWidget() w.resize(250, 150) w.move(300, 300) w.setWindowTitle('Simple') w.show() sys.exit(app.exec_()) 上面代码展示一个小窗口 12import sysfrom PyQt5.QtWidgets import QApplication, QWidget 导入必要的模块。基本的小部件在PyQt5.QtWidgets 模块中。 1app = QApplication(sys.argv) 每个PyQt5 应用必须创建一个application 对象。sys.argv 参数是命令行参数的列表。Python 脚本可以从shell运行，通过这种方式可以控制脚本的启动方式。1w = QWidget() QWidget 部件是PyQt5中所有用户界面对象的基类。我们提供了默认的QWidget构造器，默认的构造器没有父级元素。（没有父级元素的部件称为窗口）1w.resize(250, 150) resize() 方法调整部件的大小. 宽度：250px； 高度：150px1w.move(300, 300) move()把部件移动到坐标为（300，300）处。1w.setWindowTitle('Simple') 设置窗口的标题。表示在标题栏展示。1w.show() show()在窗口上显示部件。部件首先在内存中创建，然后在屏幕上展示。1sys.exit(app.exec_()) 最后，进入应用主循环。事件处理从此调用开始。主循环从窗口系统接收事件、把分发事件到应用部件。当exit()调用或主部件销毁即引发主循环结束。sys.exit() 方法确保干净的退出，通知系统应用如何退出。 exec_() 方法包含一个下划线。 因为exec 是Python的关键字,因此使用exec_()代替。 应用程序图标 (application icon)应用图标是标题栏左上角显示的小图像，接下来的例子会教大家如何在PyQt5中实现应用图标，顺带介绍一些新的方法调用。 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows an iconin the titlebar of the window.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QApplication, QWidgetfrom PyQt5.QtGui import QIconclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 300, 220) self.setWindowTitle('Icon') self.setWindowIcon(QIcon('./image/web.png')) self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 提示 （Tooltip）对每一个部件可以提供一个帮助提示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This example shows a tooltip on a window and a button.author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication)from PyQt5.QtGui import QFont class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): QToolTip.setFont(QFont('SansSerif', 10)) self.setToolTip('This is a &lt;b&gt;QWidget&lt;/b&gt; widget') btn = QPushButton('Button', self) btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') btn.resize(btn.sizeHint()) btn.move(50, 50) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Tooltips') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 本例中展现了如何为PyQt5 部件添加 tooltip。 1QToolTip.setFont(QFont('SansSerif', 10)) 此静态方法设置tooltop渲染的字体，这里使用了SansSerif字体,大小为10px。 1self.setToolTip(&apos;This is a &lt;b&gt;QWidget&lt;/b&gt; widget&apos;) 使用setToolTip 设置 tooltip， 可以使用富文本格式。 12btn = QPushButton('Button', self)btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') 添加push button 部件，及为push button 设置tooltip。 12btn.resize(btn.sizeHint())btn.move(50, 50) button 在窗口中重新设置大小、移动位置。 sizeHint() 使得 button 能够获得一个推荐适当的大小。 Figure: Tooltip 关闭窗口关闭窗口最明显的方式就是“点击标题栏的x标记”。在下一个例子中，我们会展示如何通过编码的方式关闭窗口。我们会开始接触到signals(信号)和 slots(槽) 。 下面是QPushButton 部件的构造函数。1QPushButton(string text, QWidget parent = None) text 参数是button上显示的文本。parent 是放置 button 的部件(widget). 在本例中他就是一个QWidget。应用中的Widegets形成层次结构，大多数Widget都有其parent，没有parent的Widgets是顶层的窗口. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program creates a quitbutton. When we press the button,the application terminates. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QPushButton, QApplicationfrom PyQt5.QtCore import QCoreApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): qbtn = QPushButton('Quit', self) qbtn.clicked.connect(QCoreApplication.instance().quit) qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Quit button') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 此例中，创建了一个退出按钮，点击按钮，程序即退出。1from PyQt5.QtCore import QCoreApplication 需要导入QtCore中的包 1qbtn = QPushButton('Quit', self) 我们新建了一个QPushButton的实例。构造函数的第一个参数是按钮的标签，第二个参数是widget的parent。此处的parent是继承的QWidget对象。 1qbtn.clicked.connect(QCoreApplication.instance().quit) PyQt5的事件处理系统构建与 signal 和 slot 机制之上。如果我们点击按钮，信号就会被激发。slot 可以是一个Qt槽、或者python 可调用对象。QCoreApplication 包括一个主事件循环（处理和分发事件循环）；instance()方法返回一个当前实例。注意：QCoreApplication 是与 QApplication 一起创建的。clicked信号连接到quit()方法【quit方法用于结束应用】。接收者（push button）和发送者（application object）中负责互相通讯。 消息框（Message Box）默认情况下，如果点击标题栏的关闭按钮（x），QWidget 将被关闭。在某些情况下需要对这种行为进行修改，比如：编辑器中有仍未保存的被修改的文件，应该在关闭时出现一个确认行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program shows a confirmation message box when we click on the closebutton of the application window. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Message box') self.show() def closeEvent(self, event): reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 当关闭此QWidget时，触发QCloseEvent事件，通过重写closeEvent()事件控制方法修改默认的关闭行为。123reply = QMessageBox.question(self, 'Message', "Are you sure to quit?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No) 显示一个带有两个按钮的消息框（yes 和 no）。第一个 字符串 参数在标题栏显示。第二个 字符串 参数是在对话框中显示的，第三个参数定义了出现在消息框中的按钮。最后一个参数定义默认的按钮。返回值传递给reply。 1234if reply == QtGui.QMessageBox.Yes: event.accept()else: event.ignore() 此处根据返回值判断是否关闭窗口，点击“yes”即接受事件，关闭widget和终止应用。否者，忽视此事件。 屏幕居中（centering window on the screen）此例展示如何在屏幕居中显示应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python3# -*- coding: utf-8 -*-"""ZetCode PyQt5 tutorial This program centers a window on the screen. author: Jan Bodnarwebsite: zetcode.com last edited: January 2015"""import sysfrom PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) self.center() self.setWindowTitle('Center') self.show() def center(self): qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() qr.moveCenter(cp) self.move(qr.topLeft()) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) QtGui.QDesktopWidget 类提供了用户桌面的相关信息，包括桌面尺寸。 1self.center() 此方法实现了将程序移到屏幕的中央。 1qr = self.frameGeometry() 获得主窗口的方框描述，包括了任何窗口框。 1cp = QDesktopWidget().availableGeometry().center() 获得屏幕geometry，通过geometry获得屏幕的中心位置。 1qr.moveCenter(cp) 将窗口的中心位置移动到屏幕的中心，窗口的大小并不发生变化 1self.move(qr.topLeft()) 移动窗口的左上角到移动到qr的左上角，这样窗口就在屏幕的正中央了。 这部分介绍了一些基本PyQt5 知识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyQt5-1 简介 【Introduction】]]></title>
      <url>%2F2017%2F03%2F18%2FPyQt5_1%2F</url>
      <content type="text"><![CDATA[原文出处: zetcode.com 关于 PyQt5 【About PyQt5】PyQt5 是Digia的Qt5应用框架的python绑定实现。在 Python2 和 Python3 环境下皆可用。本教程使用 Python3。Qt 是最强大的GUI库之一。PyQt5的官方网站是www.riverbankcomputing.co.uk/news。PyQt5 由 Riverbank Computing 开发并维护。 PyQt5 以一系列Python模块的形式实现，其具有620个以上的类和6000个函数、方法。它是个跨平台的工具集（Unix、windows、mac）。PyQt5使用2个发行协议（GPL 和 商业协议） PyQt5 划分为以下几个模块： QtCoreQtCore 模块包含了核心的非GUI功能。此模块用于处理 time、files与 directories、不同的数据类型、流、URLs、mine types、线程或进程。 QtGuiQtGui 包括集成的窗口系统、事件处理、2D Graphics、basic imaging、字体、文本。 QtWidgetsQtWidgets 提供基本UI元素（以类的方式）创建典型的桌面用户界面。 QtMultimediaQtMultimedia 包括处理多媒体内容的类和访问camera、radio功能的Api QtBluetookQtBluetooh 模块包括蓝牙的扫描、链接及交互功能 QtNetworkQtNetwork 模块用于网络编程。此模块实现了TCP/IP 和 UDP 客户端、服务器使得网络编程更加简单和可移植。 QtPositioningQtPositioning 用于从多种源头获取位置信息；比如 satellite、Wifi、或文本文件。 EnginioEnginio 提供了client-side library用于访问Qt Cloud Services Managed Application Runtime。 QtWebSocketsQtWebSockets 实现了 WebSocket 协议 QtWebkitQtWebkit 提供了一个基于WebKit2库的web浏览器实现。 QtWebkitWidgetsQtWebkitWidgets 提供了在QtWidgets应用中使用的基于Webkit1的浏览器。 QtXmlQtXml 用于处理xml文件，此模块提供了基于SAX和DOM 的api QtSvgQtSvg 模块用于显示SVG文件。Scalable Vector Graphics (SVG) 是一种用XML描述二维图像、图形应用的语言。 QtSqlQtSQL 用于数据库相关工作。 QtTestQtTest 用于 PyQt5 应用的单元测试。 PyQt4 和 PyQt5 的区别 【Difference between PyQt4 and PyQt5】PyQt5 并不向后兼容（向下兼容）PyQt4; PyQt5 中发生了几大显著变化。然而把旧版本的代码重构到新的库中并不十分困难。PyQt5与PyQt4 的区别具体为： Python 的模块重新组织。一些模块被丢弃了（比如QtScript）,有些被划分到子模块中（比如QtGui、 QtWebKit）。 引入了新的模块，包括 QtBluetooth， QtPositioning、Enginio。 PyQt5 只支持新式的“信号-槽”事件处理机制。SIGNAL() 和 SLOT() 调用不再被支持。 PyQt5 不再支持任何在Qt v5.0被声明为deprecated（不提倡使用）或obsolete（废弃）的 Qt API。 PythonPython 是一种高级、动态、通用、跨平台、解释性、面向对象的编程语言。 Python的设计目的是突出程序员的效率和代码可读性。Python最开始由 Guido van Rossum 开发，于1991年首次发布。Python受ABC、Haskell、Java、Lisp、Icon、Perl启发。Python 简洁抽象，最直观的特性之一就是其代码使用缩进代替分号和花括号。Python目前有两大分支-Python2.x、Python3.x，Python3.x打破了向后兼容性，其目的是修正存在的设计错误，使得语言更加干净。Python由世界上的志愿者进行维护，它是开源的，Python是学习编程的理想入门语言。 本教程使用Python3.x 版本。 Python支持多种编程类型。它并不规范于特定的范式。Python 支持面向对象 与过程化编程。也提供有限的函数式编程支持。 Python的官方站点是 python.org Perl、Python、 Ruby 是广泛使用的脚本语言。它们存在诸多相同点；互相竞争。 本章节是PyQt5 工具集的介绍。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[First Blog]]></title>
      <url>%2F2017%2F03%2F15%2Fhello%2F</url>
      <content type="text"><![CDATA[不可避俗的来一句：hello world!很想做个人博客，静态博客工具提供了一种很廉价的创建博客方式！在pelican、hugo、hexo三者中，我最终选择了hexo 与其中的 next 主题。真的很感谢hexo 与next主题的创建者们！！！！ 原本有想法自己做一个~但是自从看到这么优秀的框架后，就打消了这个念头！！！界面很优秀、很有趣！ 配置结合github 提供的 pages 服务构建个人网站。简单记录一下配置过程： 安装 node\npm这个参考网上教程就好，注意设置环境变量 安装 hexo123456789101112# 安装 hexonpm install hexo-cli -g# 初始化博客hexo init &lt;博客位置&gt;cd &lt;博客位置&gt;# 安装相应依赖npm install# 本地搜索插件npm install hexo-generator-searchdb --save# 启动ｈｅｘｏ服务器hexo server 安装 next 主题12$ cd &lt;博客位置&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 注意将 next中的.git 目录删掉，因为之后要用自己的git仓库托管。 hexo 博客设置hexo 博客配置文件位于 &lt;博客位置&gt;/_config.yml 修改以下项目，根据自己需要修改：12345678title: &lt;博客标题&gt;subtitle: &lt;博客子标题&gt;description: &lt;博客描述&gt;author: &lt;你的名字&gt;language: zh-Hansurl: &lt;个人博客url&gt; 启用next主题1theme: next 配置git-pages位置123456# Deployment## Docs: 设置部署位置，此处使用git-pages服务deploy: type: git repo: git@github.com:dandan32/dandan32.github.io.git branch: master 配置本地搜索123456# 搜索设置search: path: search.xml field: post format: html limit: 10000 主题博客配置参考官方教程]]></content>
    </entry>

    
  
  
</search>
